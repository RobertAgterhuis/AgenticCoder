/**
 * Event Handler Template: {{handlerName}}
 * {{description}}
 * 
 * Event Type: {{eventType}}
 * Generated by AgenticCoder
 */

{{#if useTypeScript}}
import { EventEmitter } from 'events';
{{#if customImports}}
{{#each customImports}}
import {{#if default}}{{default}}{{else}}{ {{named}} }{{/if}} from '{{from}}';
{{/each}}
{{/if}}

// Event Types
{{#each events}}
export interface {{pascalCase name}}Event {
{{#each properties}}
  {{name}}: {{type}};
{{/each}}
  timestamp: Date;
  correlationId: string;
  {{#if metadata}}
  metadata: {
    {{#each metadata}}
    {{name}}: {{type}};
    {{/each}}
  };
  {{/if}}
}

{{/each}}

// Event Handler Interface
export interface IEventHandler<T> {
  eventType: string;
  handle(event: T): Promise<void>;
  canHandle(event: unknown): boolean;
}

// Base Event Handler
export abstract class BaseEventHandler<T> implements IEventHandler<T> {
  abstract eventType: string;
  
  protected readonly logger: Console;
  protected readonly maxRetries: number;
  protected readonly retryDelay: number;
  
  constructor(options: { maxRetries?: number; retryDelay?: number } = {}) {
    this.logger = console;
    this.maxRetries = options.maxRetries ?? {{maxRetries}};
    this.retryDelay = options.retryDelay ?? {{retryDelay}};
  }
  
  abstract handle(event: T): Promise<void>;
  
  canHandle(event: unknown): boolean {
    return this.isValidEvent(event);
  }
  
  protected abstract isValidEvent(event: unknown): event is T;
  
  protected async withRetry<R>(
    operation: () => Promise<R>,
    context: string
  ): Promise<R> {
    let lastError: Error | undefined;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        this.logger.warn(
          `Attempt ${attempt}/${this.maxRetries} failed for ${context}:`,
          error
        );
        
        if (attempt < this.maxRetries) {
          await this.delay(this.retryDelay * attempt);
        }
      }
    }
    
    throw lastError;
  }
  
  protected delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// {{pascalCase handlerName}} Handler
export class {{pascalCase handlerName}}Handler extends BaseEventHandler<{{eventInterface}}> {
  eventType = '{{eventType}}';
  
  {{#if dependencies}}
  constructor(
    {{#each dependencies}}
    private readonly {{camelCase name}}: {{type}},
    {{/each}}
    options?: { maxRetries?: number; retryDelay?: number }
  ) {
    super(options);
  }
  {{/if}}
  
  protected isValidEvent(event: unknown): event is {{eventInterface}} {
    if (!event || typeof event !== 'object') return false;
    const e = event as Record<string, unknown>;
    return (
      {{#each validationFields}}
      typeof e.{{name}} === '{{type}}'{{#unless @last}} &&{{/unless}}
      {{/each}}
    );
  }
  
  async handle(event: {{eventInterface}}): Promise<void> {
    this.logger.log(`Processing {{eventType}} event:`, event.correlationId);
    
    try {
      // Pre-processing hooks
      await this.beforeHandle(event);
      
      {{#if transactional}}
      // Transactional processing
      await this.withRetry(async () => {
        {{handlerBody}}
      }, '{{handlerName}}');
      {{else}}
      // Event processing
      {{handlerBody}}
      {{/if}}
      
      // Post-processing hooks
      await this.afterHandle(event);
      
      this.logger.log(`Successfully processed {{eventType}} event:`, event.correlationId);
    } catch (error) {
      this.logger.error(`Failed to process {{eventType}} event:`, error);
      await this.onError(event, error as Error);
      throw error;
    }
  }
  
  protected async beforeHandle(event: {{eventInterface}}): Promise<void> {
    // Override for pre-processing logic
    {{#if beforeHandleBody}}
    {{beforeHandleBody}}
    {{/if}}
  }
  
  protected async afterHandle(event: {{eventInterface}}): Promise<void> {
    // Override for post-processing logic
    {{#if afterHandleBody}}
    {{afterHandleBody}}
    {{/if}}
  }
  
  protected async onError(event: {{eventInterface}}, error: Error): Promise<void> {
    // Override for error handling logic
    {{#if onErrorBody}}
    {{onErrorBody}}
    {{/if}}
  }
}

// Event Handler Registry
export class EventHandlerRegistry {
  private handlers: Map<string, IEventHandler<unknown>[]> = new Map();
  
  register<T>(handler: IEventHandler<T>): void {
    const handlers = this.handlers.get(handler.eventType) ?? [];
    handlers.push(handler as IEventHandler<unknown>);
    this.handlers.set(handler.eventType, handlers);
  }
  
  unregister<T>(handler: IEventHandler<T>): void {
    const handlers = this.handlers.get(handler.eventType);
    if (handlers) {
      const index = handlers.indexOf(handler as IEventHandler<unknown>);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }
  
  async dispatch(eventType: string, event: unknown): Promise<void> {
    const handlers = this.handlers.get(eventType) ?? [];
    
    if (handlers.length === 0) {
      console.warn(`No handlers registered for event type: ${eventType}`);
      return;
    }
    
    const applicableHandlers = handlers.filter(h => h.canHandle(event));
    
    await Promise.all(
      applicableHandlers.map(handler => handler.handle(event))
    );
  }
  
  getHandlers(eventType: string): IEventHandler<unknown>[] {
    return this.handlers.get(eventType) ?? [];
  }
}

// Export singleton registry
export const eventHandlerRegistry = new EventHandlerRegistry();

{{else}}
// JavaScript version
const { EventEmitter } = require('events');

class BaseEventHandler {
  constructor(options = {}) {
    this.logger = console;
    this.maxRetries = options.maxRetries ?? {{maxRetries}};
    this.retryDelay = options.retryDelay ?? {{retryDelay}};
  }
  
  canHandle(event) {
    return this.isValidEvent(event);
  }
  
  async withRetry(operation, context) {
    let lastError;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        this.logger.warn(`Attempt ${attempt}/${this.maxRetries} failed for ${context}:`, error);
        
        if (attempt < this.maxRetries) {
          await this.delay(this.retryDelay * attempt);
        }
      }
    }
    
    throw lastError;
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

class {{pascalCase handlerName}}Handler extends BaseEventHandler {
  constructor({{#if dependencies}}{{#each dependencies}}{{camelCase name}}, {{/each}}{{/if}}options) {
    super(options);
    this.eventType = '{{eventType}}';
    {{#each dependencies}}
    this.{{camelCase name}} = {{camelCase name}};
    {{/each}}
  }
  
  isValidEvent(event) {
    return event && typeof event === 'object';
  }
  
  async handle(event) {
    this.logger.log(`Processing {{eventType}} event:`, event.correlationId);
    
    try {
      await this.beforeHandle(event);
      {{handlerBody}}
      await this.afterHandle(event);
      this.logger.log(`Successfully processed {{eventType}} event:`, event.correlationId);
    } catch (error) {
      this.logger.error(`Failed to process {{eventType}} event:`, error);
      await this.onError(event, error);
      throw error;
    }
  }
  
  async beforeHandle(event) {}
  async afterHandle(event) {}
  async onError(event, error) {}
}

module.exports = { BaseEventHandler, {{pascalCase handlerName}}Handler };
{{/if}}
