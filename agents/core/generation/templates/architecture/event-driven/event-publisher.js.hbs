/**
 * Event Publisher Template: {{publisherName}}
 * {{description}}
 * 
 * Generated by AgenticCoder
 */

{{#if useTypeScript}}
{{#if customImports}}
{{#each customImports}}
import {{#if default}}{{default}}{{else}}{ {{named}} }{{/if}} from '{{from}}';
{{/each}}
{{/if}}

// Event Envelope
export interface EventEnvelope<T = unknown> {
  id: string;
  type: string;
  source: string;
  specversion: string;
  time: string;
  datacontenttype: string;
  data: T;
  subject?: string;
  correlationId?: string;
  {{#if customEnvelopeFields}}
  {{#each customEnvelopeFields}}
  {{name}}?: {{type}};
  {{/each}}
  {{/if}}
}

// Publisher Options
export interface PublisherOptions {
  source: string;
  {{#if retryOptions}}
  retry?: {
    maxRetries: number;
    initialDelay: number;
    maxDelay: number;
    backoffMultiplier: number;
  };
  {{/if}}
  {{#if batchOptions}}
  batch?: {
    maxSize: number;
    maxWaitMs: number;
  };
  {{/if}}
  {{#if customOptions}}
  {{#each customOptions}}
  {{name}}?: {{type}};
  {{/each}}
  {{/if}}
}

// Base Event Publisher
export abstract class BaseEventPublisher {
  protected readonly source: string;
  protected readonly specversion = '1.0';
  {{#if retryOptions}}
  protected readonly retryOptions: Required<PublisherOptions['retry']>;
  {{/if}}
  {{#if batchOptions}}
  protected readonly batchOptions: Required<PublisherOptions['batch']>;
  protected eventBuffer: EventEnvelope[] = [];
  protected flushTimer?: NodeJS.Timeout;
  {{/if}}
  
  constructor(options: PublisherOptions) {
    this.source = options.source;
    {{#if retryOptions}}
    this.retryOptions = {
      maxRetries: options.retry?.maxRetries ?? {{retryOptions.maxRetries}},
      initialDelay: options.retry?.initialDelay ?? {{retryOptions.initialDelay}},
      maxDelay: options.retry?.maxDelay ?? {{retryOptions.maxDelay}},
      backoffMultiplier: options.retry?.backoffMultiplier ?? {{retryOptions.backoffMultiplier}},
    };
    {{/if}}
    {{#if batchOptions}}
    this.batchOptions = {
      maxSize: options.batch?.maxSize ?? {{batchOptions.maxSize}},
      maxWaitMs: options.batch?.maxWaitMs ?? {{batchOptions.maxWaitMs}},
    };
    {{/if}}
  }
  
  protected createEnvelope<T>(
    type: string,
    data: T,
    options?: Partial<EventEnvelope<T>>
  ): EventEnvelope<T> {
    return {
      id: this.generateId(),
      type,
      source: this.source,
      specversion: this.specversion,
      time: new Date().toISOString(),
      datacontenttype: 'application/json',
      data,
      ...options,
    };
  }
  
  protected generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  {{#if retryOptions}}
  protected async withRetry<T>(
    operation: () => Promise<T>,
    context: string
  ): Promise<T> {
    let lastError: Error | undefined;
    let delay = this.retryOptions.initialDelay;
    
    for (let attempt = 1; attempt <= this.retryOptions.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        console.warn(`Attempt ${attempt}/${this.retryOptions.maxRetries} failed for ${context}:`, error);
        
        if (attempt < this.retryOptions.maxRetries) {
          await this.delay(delay);
          delay = Math.min(delay * this.retryOptions.backoffMultiplier, this.retryOptions.maxDelay);
        }
      }
    }
    
    throw lastError;
  }
  
  protected delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  {{/if}}
  
  abstract publish<T>(type: string, data: T, options?: Partial<EventEnvelope<T>>): Promise<void>;
  {{#if batchOptions}}
  abstract publishBatch(events: EventEnvelope[]): Promise<void>;
  abstract flush(): Promise<void>;
  {{/if}}
}

// {{pascalCase publisherName}} Publisher
export class {{pascalCase publisherName}}Publisher extends BaseEventPublisher {
  {{#if dependencies}}
  constructor(
    {{#each dependencies}}
    private readonly {{camelCase name}}: {{type}},
    {{/each}}
    options: PublisherOptions
  ) {
    super(options);
  }
  {{/if}}
  
  async publish<T>(
    type: string,
    data: T,
    options?: Partial<EventEnvelope<T>>
  ): Promise<void> {
    const envelope = this.createEnvelope(type, data, options);
    
    {{#if batchOptions}}
    // Add to batch
    this.eventBuffer.push(envelope as EventEnvelope);
    
    if (this.eventBuffer.length >= this.batchOptions.maxSize) {
      await this.flush();
    } else if (!this.flushTimer) {
      this.flushTimer = setTimeout(async () => {
        await this.flush();
      }, this.batchOptions.maxWaitMs);
    }
    {{else}}
    {{#if retryOptions}}
    await this.withRetry(async () => {
      await this.send(envelope);
    }, `publish ${type}`);
    {{else}}
    await this.send(envelope);
    {{/if}}
    {{/if}}
    
    console.log(`Published event: ${type}`, envelope.id);
  }
  
  {{#if batchOptions}}
  async publishBatch(events: EventEnvelope[]): Promise<void> {
    {{#if retryOptions}}
    await this.withRetry(async () => {
      await this.sendBatch(events);
    }, 'publishBatch');
    {{else}}
    await this.sendBatch(events);
    {{/if}}
  }
  
  async flush(): Promise<void> {
    if (this.flushTimer) {
      clearTimeout(this.flushTimer);
      this.flushTimer = undefined;
    }
    
    if (this.eventBuffer.length === 0) {
      return;
    }
    
    const events = [...this.eventBuffer];
    this.eventBuffer = [];
    
    await this.publishBatch(events);
    console.log(`Flushed ${events.length} events`);
  }
  
  protected async sendBatch(events: EventEnvelope[]): Promise<void> {
    {{sendBatchBody}}
  }
  {{/if}}
  
  protected async send<T>(envelope: EventEnvelope<T>): Promise<void> {
    {{sendBody}}
  }
  
  {{#if publishHelpers}}
  // Typed publish helpers
  {{#each publishHelpers}}
  async publish{{pascalCase eventType}}(data: {{dataType}}, correlationId?: string): Promise<void> {
    await this.publish('{{eventType}}', data, { correlationId });
  }
  
  {{/each}}
  {{/if}}
}

// Event Publisher Factory
export function createPublisher(
  type: '{{publisherType}}'{{#if factoryOptions}},
  config: {
    {{#each factoryOptions}}
    {{name}}: {{type}};
    {{/each}}
  }{{/if}}
): {{pascalCase publisherName}}Publisher {
  {{factoryBody}}
}

// Export default publisher instance
export const defaultPublisher = createPublisher('{{publisherType}}'{{#if defaultConfig}}, {{defaultConfig}}{{/if}});

{{else}}
// JavaScript version
class BaseEventPublisher {
  constructor(options) {
    this.source = options.source;
    this.specversion = '1.0';
    {{#if retryOptions}}
    this.retryOptions = {
      maxRetries: options.retry?.maxRetries ?? {{retryOptions.maxRetries}},
      initialDelay: options.retry?.initialDelay ?? {{retryOptions.initialDelay}},
      maxDelay: options.retry?.maxDelay ?? {{retryOptions.maxDelay}},
      backoffMultiplier: options.retry?.backoffMultiplier ?? {{retryOptions.backoffMultiplier}},
    };
    {{/if}}
    {{#if batchOptions}}
    this.batchOptions = {
      maxSize: options.batch?.maxSize ?? {{batchOptions.maxSize}},
      maxWaitMs: options.batch?.maxWaitMs ?? {{batchOptions.maxWaitMs}},
    };
    this.eventBuffer = [];
    this.flushTimer = null;
    {{/if}}
  }
  
  createEnvelope(type, data, options = {}) {
    return {
      id: this.generateId(),
      type,
      source: this.source,
      specversion: this.specversion,
      time: new Date().toISOString(),
      datacontenttype: 'application/json',
      data,
      ...options,
    };
  }
  
  generateId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

class {{pascalCase publisherName}}Publisher extends BaseEventPublisher {
  async publish(type, data, options) {
    const envelope = this.createEnvelope(type, data, options);
    await this.send(envelope);
    console.log(`Published event: ${type}`, envelope.id);
  }
  
  async send(envelope) {
    {{sendBody}}
  }
}

module.exports = { BaseEventPublisher, {{pascalCase publisherName}}Publisher };
{{/if}}
