/**
 * Saga Orchestrator Template: {{sagaName}}
 * {{description}}
 * 
 * Pattern: Saga (Orchestration)
 * Generated by AgenticCoder
 */

{{#if useTypeScript}}
{{#if customImports}}
{{#each customImports}}
import {{#if default}}{{default}}{{else}}{ {{named}} }{{/if}} from '{{from}}';
{{/each}}
{{/if}}

// Saga Step Status
export enum SagaStepStatus {
  PENDING = 'PENDING',
  RUNNING = 'RUNNING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  COMPENSATING = 'COMPENSATING',
  COMPENSATED = 'COMPENSATED',
  COMPENSATION_FAILED = 'COMPENSATION_FAILED',
}

// Saga Status
export enum SagaStatus {
  STARTED = 'STARTED',
  RUNNING = 'RUNNING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  COMPENSATING = 'COMPENSATING',
  COMPENSATED = 'COMPENSATED',
}

// Saga Step Definition
export interface SagaStep<TInput = unknown, TOutput = unknown> {
  name: string;
  execute: (input: TInput, context: SagaContext) => Promise<TOutput>;
  compensate?: (input: TInput, output: TOutput, context: SagaContext) => Promise<void>;
  {{#if stepOptions}}
  options?: {
    timeout?: number;
    retries?: number;
    retryDelay?: number;
  };
  {{/if}}
}

// Saga Step Result
export interface SagaStepResult<T = unknown> {
  stepName: string;
  status: SagaStepStatus;
  output?: T;
  error?: Error;
  startedAt: Date;
  completedAt?: Date;
}

// Saga Context
export interface SagaContext {
  sagaId: string;
  correlationId: string;
  startedAt: Date;
  stepResults: Map<string, SagaStepResult>;
  metadata: Record<string, unknown>;
  {{#if contextExtensions}}
  {{#each contextExtensions}}
  {{name}}: {{type}};
  {{/each}}
  {{/if}}
}

// Saga Result
export interface SagaResult<T = unknown> {
  sagaId: string;
  status: SagaStatus;
  result?: T;
  error?: Error;
  stepResults: SagaStepResult[];
  startedAt: Date;
  completedAt: Date;
  duration: number;
}

// Saga State (for persistence)
export interface SagaState {
  sagaId: string;
  sagaName: string;
  status: SagaStatus;
  currentStep: number;
  input: unknown;
  stepResults: SagaStepResult[];
  context: Omit<SagaContext, 'stepResults'>;
  createdAt: Date;
  updatedAt: Date;
}

// Saga Store Interface
export interface ISagaStore {
  save(state: SagaState): Promise<void>;
  load(sagaId: string): Promise<SagaState | null>;
  update(sagaId: string, updates: Partial<SagaState>): Promise<void>;
  delete(sagaId: string): Promise<void>;
}

// In-Memory Saga Store
export class InMemorySagaStore implements ISagaStore {
  private store = new Map<string, SagaState>();
  
  async save(state: SagaState): Promise<void> {
    this.store.set(state.sagaId, { ...state });
  }
  
  async load(sagaId: string): Promise<SagaState | null> {
    return this.store.get(sagaId) ?? null;
  }
  
  async update(sagaId: string, updates: Partial<SagaState>): Promise<void> {
    const existing = this.store.get(sagaId);
    if (existing) {
      this.store.set(sagaId, { ...existing, ...updates, updatedAt: new Date() });
    }
  }
  
  async delete(sagaId: string): Promise<void> {
    this.store.delete(sagaId);
  }
}

// Base Saga Orchestrator
export abstract class BaseSagaOrchestrator<TInput, TOutput> {
  protected abstract sagaName: string;
  protected abstract steps: SagaStep[];
  
  protected store: ISagaStore;
  protected logger: Console;
  protected defaultTimeout: number;
  protected defaultRetries: number;
  
  constructor(options: {
    store?: ISagaStore;
    defaultTimeout?: number;
    defaultRetries?: number;
  } = {}) {
    this.store = options.store ?? new InMemorySagaStore();
    this.logger = console;
    this.defaultTimeout = options.defaultTimeout ?? {{defaultTimeout}};
    this.defaultRetries = options.defaultRetries ?? {{defaultRetries}};
  }
  
  protected generateId(): string {
    return `saga-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  async execute(input: TInput, correlationId?: string): Promise<SagaResult<TOutput>> {
    const sagaId = this.generateId();
    const startedAt = new Date();
    
    const context: SagaContext = {
      sagaId,
      correlationId: correlationId ?? sagaId,
      startedAt,
      stepResults: new Map(),
      metadata: {},
    };
    
    // Save initial state
    await this.store.save({
      sagaId,
      sagaName: this.sagaName,
      status: SagaStatus.STARTED,
      currentStep: 0,
      input,
      stepResults: [],
      context: { ...context, stepResults: undefined as any },
      createdAt: startedAt,
      updatedAt: startedAt,
    });
    
    this.logger.log(`Starting saga: ${this.sagaName} (${sagaId})`);
    
    let currentStepIndex = 0;
    let lastOutput: unknown = input;
    let sagaError: Error | undefined;
    
    try {
      // Execute forward steps
      for (const step of this.steps) {
        const stepResult = await this.executeStep(step, lastOutput, context);
        context.stepResults.set(step.name, stepResult);
        
        if (stepResult.status === SagaStepStatus.FAILED) {
          throw stepResult.error ?? new Error(`Step ${step.name} failed`);
        }
        
        lastOutput = stepResult.output;
        currentStepIndex++;
        
        // Update state
        await this.store.update(sagaId, {
          currentStep: currentStepIndex,
          stepResults: Array.from(context.stepResults.values()),
          status: SagaStatus.RUNNING,
        });
      }
      
      // Saga completed successfully
      const completedAt = new Date();
      await this.store.update(sagaId, {
        status: SagaStatus.COMPLETED,
        stepResults: Array.from(context.stepResults.values()),
      });
      
      this.logger.log(`Saga completed: ${this.sagaName} (${sagaId})`);
      
      return {
        sagaId,
        status: SagaStatus.COMPLETED,
        result: lastOutput as TOutput,
        stepResults: Array.from(context.stepResults.values()),
        startedAt,
        completedAt,
        duration: completedAt.getTime() - startedAt.getTime(),
      };
      
    } catch (error) {
      sagaError = error as Error;
      this.logger.error(`Saga failed at step ${currentStepIndex}: ${sagaError.message}`);
      
      // Begin compensation
      await this.store.update(sagaId, {
        status: SagaStatus.COMPENSATING,
      });
      
      await this.compensate(context, currentStepIndex - 1, input);
      
      const completedAt = new Date();
      const finalStatus = this.hasCompensationFailures(context)
        ? SagaStatus.FAILED
        : SagaStatus.COMPENSATED;
      
      await this.store.update(sagaId, {
        status: finalStatus,
        stepResults: Array.from(context.stepResults.values()),
      });
      
      return {
        sagaId,
        status: finalStatus,
        error: sagaError,
        stepResults: Array.from(context.stepResults.values()),
        startedAt,
        completedAt,
        duration: completedAt.getTime() - startedAt.getTime(),
      };
    }
  }
  
  protected async executeStep(
    step: SagaStep,
    input: unknown,
    context: SagaContext
  ): Promise<SagaStepResult> {
    const startedAt = new Date();
    const timeout = step.options?.timeout ?? this.defaultTimeout;
    const retries = step.options?.retries ?? this.defaultRetries;
    
    this.logger.log(`Executing step: ${step.name}`);
    
    let lastError: Error | undefined;
    
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        const output = await Promise.race([
          step.execute(input, context),
          this.createTimeout(timeout, step.name),
        ]);
        
        return {
          stepName: step.name,
          status: SagaStepStatus.COMPLETED,
          output,
          startedAt,
          completedAt: new Date(),
        };
      } catch (error) {
        lastError = error as Error;
        this.logger.warn(`Step ${step.name} attempt ${attempt}/${retries} failed:`, error);
        
        if (attempt < retries) {
          await this.delay(step.options?.retryDelay ?? 1000);
        }
      }
    }
    
    return {
      stepName: step.name,
      status: SagaStepStatus.FAILED,
      error: lastError,
      startedAt,
      completedAt: new Date(),
    };
  }
  
  protected async compensate(
    context: SagaContext,
    fromStepIndex: number,
    originalInput: unknown
  ): Promise<void> {
    this.logger.log(`Starting compensation from step ${fromStepIndex}`);
    
    for (let i = fromStepIndex; i >= 0; i--) {
      const step = this.steps[i];
      const stepResult = context.stepResults.get(step.name);
      
      if (!step.compensate || stepResult?.status !== SagaStepStatus.COMPLETED) {
        continue;
      }
      
      this.logger.log(`Compensating step: ${step.name}`);
      
      const compensationResult: SagaStepResult = {
        stepName: `${step.name}_compensation`,
        status: SagaStepStatus.COMPENSATING,
        startedAt: new Date(),
      };
      
      try {
        await step.compensate(originalInput, stepResult.output, context);
        compensationResult.status = SagaStepStatus.COMPENSATED;
        compensationResult.completedAt = new Date();
        this.logger.log(`Step ${step.name} compensated successfully`);
      } catch (error) {
        compensationResult.status = SagaStepStatus.COMPENSATION_FAILED;
        compensationResult.error = error as Error;
        compensationResult.completedAt = new Date();
        this.logger.error(`Compensation failed for step ${step.name}:`, error);
      }
      
      context.stepResults.set(`${step.name}_compensation`, compensationResult);
    }
  }
  
  protected hasCompensationFailures(context: SagaContext): boolean {
    return Array.from(context.stepResults.values()).some(
      r => r.status === SagaStepStatus.COMPENSATION_FAILED
    );
  }
  
  protected createTimeout(ms: number, stepName: string): Promise<never> {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error(`Step ${stepName} timed out after ${ms}ms`)), ms)
    );
  }
  
  protected delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // Resume a failed saga (for recovery)
  async resume(sagaId: string): Promise<SagaResult<TOutput> | null> {
    const state = await this.store.load(sagaId);
    if (!state || state.status === SagaStatus.COMPLETED) {
      return null;
    }
    
    this.logger.log(`Resuming saga: ${sagaId} from step ${state.currentStep}`);
    // Implementation depends on specific requirements
    return null;
  }
}

// {{pascalCase sagaName}} Saga Implementation
export class {{pascalCase sagaName}}Saga extends BaseSagaOrchestrator<{{inputType}}, {{outputType}}> {
  protected sagaName = '{{sagaName}}';
  
  protected steps: SagaStep[] = [
    {{#each steps}}
    {
      name: '{{name}}',
      execute: async (input, context) => {
        {{executeBody}}
      },
      {{#if compensate}}
      compensate: async (input, output, context) => {
        {{compensateBody}}
      },
      {{/if}}
      {{#if options}}
      options: {
        {{#each options}}
        {{key}}: {{value}},
        {{/each}}
      },
      {{/if}}
    },
    {{/each}}
  ];
  
  {{#if dependencies}}
  constructor(
    {{#each dependencies}}
    private readonly {{camelCase name}}: {{type}},
    {{/each}}
    options?: { store?: ISagaStore; defaultTimeout?: number; defaultRetries?: number }
  ) {
    super(options);
  }
  {{/if}}
}

// Export default saga instance
export const {{camelCase sagaName}}Saga = new {{pascalCase sagaName}}Saga({{#if defaultDependencies}}{{defaultDependencies}}{{/if}});

{{else}}
// JavaScript version
const SagaStepStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  COMPENSATING: 'COMPENSATING',
  COMPENSATED: 'COMPENSATED',
  COMPENSATION_FAILED: 'COMPENSATION_FAILED',
};

const SagaStatus = {
  STARTED: 'STARTED',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  COMPENSATING: 'COMPENSATING',
  COMPENSATED: 'COMPENSATED',
};

class InMemorySagaStore {
  constructor() {
    this.store = new Map();
  }
  
  async save(state) {
    this.store.set(state.sagaId, { ...state });
  }
  
  async load(sagaId) {
    return this.store.get(sagaId) ?? null;
  }
  
  async update(sagaId, updates) {
    const existing = this.store.get(sagaId);
    if (existing) {
      this.store.set(sagaId, { ...existing, ...updates, updatedAt: new Date() });
    }
  }
  
  async delete(sagaId) {
    this.store.delete(sagaId);
  }
}

class {{pascalCase sagaName}}Saga {
  constructor(options = {}) {
    this.sagaName = '{{sagaName}}';
    this.store = options.store ?? new InMemorySagaStore();
    this.logger = console;
    this.defaultTimeout = options.defaultTimeout ?? {{defaultTimeout}};
    this.defaultRetries = options.defaultRetries ?? {{defaultRetries}};
    
    this.steps = [
      {{#each steps}}
      {
        name: '{{name}}',
        execute: async (input, context) => {
          {{executeBody}}
        },
        {{#if compensate}}
        compensate: async (input, output, context) => {
          {{compensateBody}}
        },
        {{/if}}
      },
      {{/each}}
    ];
  }
  
  async execute(input, correlationId) {
    // Implementation
  }
}

module.exports = { {{pascalCase sagaName}}Saga, SagaStatus, SagaStepStatus, InMemorySagaStore };
{{/if}}
