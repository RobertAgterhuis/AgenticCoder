/**
 * Azure Durable Function Template: {{orchestrationName}}
 * {{description}}
 * 
 * Pattern: {{pattern}}
 * Generated by AgenticCoder
 */

{{#if useTypeScript}}
import * as df from 'durable-functions';
import { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions';
{{#if customImports}}
{{#each customImports}}
import {{#if default}}{{default}}{{else}}{ {{named}} }{{/if}} from '{{from}}';
{{/each}}
{{/if}}

{{#if interfaces}}
{{#each interfaces}}
interface {{name}} {
{{#each properties}}
  {{name}}{{#if optional}}?{{/if}}: {{type}};
{{/each}}
}

{{/each}}
{{/if}}

// ============================================
// HTTP Starter Function
// ============================================
app.http('{{orchestrationName}}HttpStart', {
  route: '{{route}}',
  methods: ['POST'],
  authLevel: '{{authLevel}}',
  extraInputs: [df.input.durableClient()],
  handler: async (request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> => {
    const client = df.getClient(context);
    
    {{#if requestBody}}
    const body = await request.json() as {{requestType}};
    {{/if}}
    
    const instanceId = await client.startNew('{{orchestrationName}}Orchestrator', {
      {{#if requestBody}}
      input: body
      {{else}}
      input: undefined
      {{/if}}
    });
    
    context.log(`Started orchestration with ID = '${instanceId}'.`);
    
    return client.createCheckStatusResponse(request, instanceId);
  }
});

// ============================================
// Orchestrator Function
// ============================================
df.app.orchestration('{{orchestrationName}}Orchestrator', function* (context: df.OrchestrationContext) {
  const input = context.df.getInput<{{inputType}}>();
  const outputs: {{outputType}}[] = [];
  
  {{#if pattern === 'chaining'}}
  // Function Chaining Pattern
  // Execute activities in sequence, passing output to next
  {{#each activities}}
  const result{{@index}} = yield context.df.callActivity('{{name}}', {{#if @first}}input{{else}}result{{subtract @index 1}}{{/if}});
  outputs.push(result{{@index}});
  {{/each}}
  
  {{/if}}
  {{#if pattern === 'fanOutFanIn'}}
  // Fan-out/Fan-in Pattern
  // Execute activities in parallel and aggregate results
  const parallelTasks: df.Task<{{activityOutputType}}>[] = [];
  
  for (const item of input.{{itemsProperty}}) {
    parallelTasks.push(context.df.callActivity('{{activityName}}', item));
  }
  
  const results = yield context.df.Task.all(parallelTasks);
  outputs.push(...results);
  
  {{#if aggregateActivity}}
  // Aggregate results
  const aggregatedResult = yield context.df.callActivity('{{aggregateActivity}}', results);
  return aggregatedResult;
  {{/if}}
  
  {{/if}}
  {{#if pattern === 'monitor'}}
  // Async HTTP APIs / Monitor Pattern
  // Poll for status or wait for external events
  const expiryTime = new Date(context.df.currentUtcDateTime);
  expiryTime.setHours(expiryTime.getHours() + {{timeoutHours}});
  
  while (context.df.currentUtcDateTime < expiryTime) {
    const status = yield context.df.callActivity('{{checkStatusActivity}}', input);
    
    if (status.{{completionProperty}}) {
      return status;
    }
    
    // Wait before next poll
    const nextCheck = new Date(context.df.currentUtcDateTime);
    nextCheck.setSeconds(nextCheck.getSeconds() + {{pollingIntervalSeconds}});
    yield context.df.createTimer(nextCheck);
  }
  
  // Timeout occurred
  return { status: 'timeout', message: 'Operation timed out' };
  
  {{/if}}
  {{#if pattern === 'humanInteraction'}}
  // Human Interaction Pattern
  // Wait for external approval event
  const approvalEvent = context.df.waitForExternalEvent<{{approvalType}}>('{{approvalEventName}}');
  const timeoutEvent = context.df.createTimer(
    new Date(context.df.currentUtcDateTime.getTime() + {{timeoutMs}})
  );
  
  // Send notification for approval
  yield context.df.callActivity('{{notificationActivity}}', {
    instanceId: context.df.instanceId,
    ...input
  });
  
  const winner = yield context.df.Task.any([approvalEvent, timeoutEvent]);
  
  if (winner === approvalEvent) {
    const approval = approvalEvent.result;
    if (approval.{{approvedProperty}}) {
      yield context.df.callActivity('{{approvedActivity}}', input);
      return { status: 'approved', result: approval };
    } else {
      yield context.df.callActivity('{{rejectedActivity}}', input);
      return { status: 'rejected', reason: approval.{{reasonProperty}} };
    }
  } else {
    yield context.df.callActivity('{{timeoutActivity}}', input);
    return { status: 'timeout', message: 'Approval timeout' };
  }
  
  {{/if}}
  {{#if pattern === 'subOrchestration'}}
  // Sub-orchestration Pattern
  // Call child orchestrations
  {{#each subOrchestrations}}
  const {{camelCase name}}Result = yield context.df.callSubOrchestrator('{{name}}Orchestrator', {{input}});
  outputs.push({{camelCase name}}Result);
  {{/each}}
  
  {{/if}}
  {{#if customOrchestrationBody}}
  // Custom orchestration logic
  {{customOrchestrationBody}}
  {{/if}}
  
  return outputs;
});

// ============================================
// Activity Functions
// ============================================
{{#each activities}}
df.app.activity('{{name}}', {
  handler: async (input: {{inputType}}, context: InvocationContext): Promise<{{outputType}}> => {
    context.log('Activity {{name}} started with input:', input);
    
    try {
      {{body}}
      
      return {{returnValue}};
    } catch (error) {
      context.error('Error in activity {{name}}:', error);
      throw error;
    }
  }
});

{{/each}}

{{#if entityFunctions}}
// ============================================
// Entity Functions (Durable Entities)
// ============================================
{{#each entityFunctions}}
df.app.entity('{{name}}', (context: df.EntityContext<{{stateType}}>) => {
  const currentState = context.df.getState(() => ({{initialState}}));
  
  switch (context.df.operationName) {
    {{#each operations}}
    case '{{name}}':
      {{body}}
      break;
    {{/each}}
    default:
      throw new Error(`Unknown operation: ${context.df.operationName}`);
  }
  
  context.df.setState(currentState);
  return currentState;
});

{{/each}}
{{/if}}

{{else}}
// JavaScript version
const df = require('durable-functions');
const { app } = require('@azure/functions');

// HTTP Starter
app.http('{{orchestrationName}}HttpStart', {
  route: '{{route}}',
  methods: ['POST'],
  authLevel: '{{authLevel}}',
  extraInputs: [df.input.durableClient()],
  handler: async (request, context) => {
    const client = df.getClient(context);
    const body = await request.json();
    
    const instanceId = await client.startNew('{{orchestrationName}}Orchestrator', { input: body });
    context.log(`Started orchestration with ID = '${instanceId}'.`);
    
    return client.createCheckStatusResponse(request, instanceId);
  }
});

// Orchestrator
df.app.orchestration('{{orchestrationName}}Orchestrator', function* (context) {
  const input = context.df.getInput();
  const outputs = [];
  
  {{orchestrationBody}}
  
  return outputs;
});

// Activities
{{#each activities}}
df.app.activity('{{name}}', {
  handler: async (input, context) => {
    context.log('Activity {{name}} started');
    {{body}}
  }
});

{{/each}}
{{/if}}
