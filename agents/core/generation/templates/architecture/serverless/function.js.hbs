/**
 * Azure Function Template: {{functionName}}
 * {{description}}
 * 
 * Trigger: {{triggerType}}
 * Generated by AgenticCoder
 */

{{#if useTypeScript}}
import { app, {{triggerImport}}{{#if outputBindings}}, output{{/if}} } from '@azure/functions';
{{#if customImports}}
{{#each customImports}}
import {{#if default}}{{default}}{{else}}{ {{named}} }{{/if}} from '{{from}}';
{{/each}}
{{/if}}

{{#if interfaces}}
{{#each interfaces}}
interface {{name}} {
{{#each properties}}
  {{name}}{{#if optional}}?{{/if}}: {{type}};
{{/each}}
}

{{/each}}
{{/if}}

{{#if outputBindings}}
// Output bindings
{{#each outputBindings}}
const {{camelCase name}}Output = output.{{type}}({
{{#each config}}
  {{key}}: '{{value}}',
{{/each}}
});
{{/each}}
{{/if}}

{{#if triggerType === 'http'}}
app.http('{{functionName}}', {
  methods: [{{#each methods}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}],
  authLevel: '{{authLevel}}',
  {{#if route}}
  route: '{{route}}',
  {{/if}}
  {{#if outputBindings}}
  extraOutputs: [{{#each outputBindings}}{{camelCase name}}Output{{#unless @last}}, {{/unless}}{{/each}}],
  {{/if}}
  handler: async (request, context) => {
    context.log('{{functionName}} function processed a request.');
    
    {{#if requestValidation}}
    // Request validation
    try {
      const body = await request.json() as {{requestType}};
      {{#each validation}}
      if ({{condition}}) {
        return { status: 400, body: '{{message}}' };
      }
      {{/each}}
    } catch (error) {
      return { status: 400, body: 'Invalid request body' };
    }
    {{/if}}
    
    try {
      {{functionBody}}
      
      {{#if outputBindings}}
      // Set output binding values
      {{#each outputBindings}}
      context.extraOutputs.set({{camelCase name}}Output, {{outputValue}});
      {{/each}}
      {{/if}}
      
      return {
        status: 200,
        {{#if responseHeaders}}
        headers: {
          {{#each responseHeaders}}
          '{{key}}': '{{value}}',
          {{/each}}
        },
        {{/if}}
        jsonBody: {{responseBody}}
      };
    } catch (error) {
      context.error('Error in {{functionName}}:', error);
      return {
        status: 500,
        body: 'Internal server error'
      };
    }
  }
});
{{/if}}

{{#if triggerType === 'timer'}}
app.timer('{{functionName}}', {
  schedule: '{{schedule}}',
  {{#if runOnStartup}}
  runOnStartup: {{runOnStartup}},
  {{/if}}
  {{#if outputBindings}}
  extraOutputs: [{{#each outputBindings}}{{camelCase name}}Output{{#unless @last}}, {{/unless}}{{/each}}],
  {{/if}}
  handler: async (timer, context) => {
    context.log('{{functionName}} timer trigger function executed at:', new Date().toISOString());
    
    if (timer.isPastDue) {
      context.log('Timer is past due!');
    }
    
    try {
      {{functionBody}}
      
      {{#if outputBindings}}
      {{#each outputBindings}}
      context.extraOutputs.set({{camelCase name}}Output, {{outputValue}});
      {{/each}}
      {{/if}}
      
      context.log('{{functionName}} completed successfully');
    } catch (error) {
      context.error('Error in {{functionName}}:', error);
      throw error;
    }
  }
});
{{/if}}

{{#if triggerType === 'queue'}}
app.storageQueue('{{functionName}}', {
  queueName: '{{queueName}}',
  connection: '{{connectionSetting}}',
  {{#if outputBindings}}
  extraOutputs: [{{#each outputBindings}}{{camelCase name}}Output{{#unless @last}}, {{/unless}}{{/each}}],
  {{/if}}
  handler: async (queueItem, context) => {
    context.log('{{functionName}} processed queue message:', queueItem);
    
    try {
      const message = typeof queueItem === 'string' ? JSON.parse(queueItem) : queueItem;
      
      {{functionBody}}
      
      {{#if outputBindings}}
      {{#each outputBindings}}
      context.extraOutputs.set({{camelCase name}}Output, {{outputValue}});
      {{/each}}
      {{/if}}
      
      context.log('{{functionName}} completed successfully');
    } catch (error) {
      context.error('Error processing queue message:', error);
      throw error;
    }
  }
});
{{/if}}

{{#if triggerType === 'blob'}}
app.storageBlob('{{functionName}}', {
  path: '{{blobPath}}',
  connection: '{{connectionSetting}}',
  {{#if outputBindings}}
  extraOutputs: [{{#each outputBindings}}{{camelCase name}}Output{{#unless @last}}, {{/unless}}{{/each}}],
  {{/if}}
  handler: async (blob, context) => {
    context.log('{{functionName}} processed blob:', context.triggerMetadata.name);
    context.log('Blob size:', blob.length, 'bytes');
    
    try {
      {{functionBody}}
      
      {{#if outputBindings}}
      {{#each outputBindings}}
      context.extraOutputs.set({{camelCase name}}Output, {{outputValue}});
      {{/each}}
      {{/if}}
      
      context.log('{{functionName}} completed successfully');
    } catch (error) {
      context.error('Error processing blob:', error);
      throw error;
    }
  }
});
{{/if}}

{{#if triggerType === 'cosmosDB'}}
app.cosmosDB('{{functionName}}', {
  databaseName: '{{databaseName}}',
  containerName: '{{containerName}}',
  connection: '{{connectionSetting}}',
  {{#if leaseContainerName}}
  leaseContainerName: '{{leaseContainerName}}',
  {{/if}}
  {{#if createLeaseContainerIfNotExists}}
  createLeaseContainerIfNotExists: {{createLeaseContainerIfNotExists}},
  {{/if}}
  {{#if outputBindings}}
  extraOutputs: [{{#each outputBindings}}{{camelCase name}}Output{{#unless @last}}, {{/unless}}{{/each}}],
  {{/if}}
  handler: async (documents, context) => {
    context.log('{{functionName}} processed', documents.length, 'document(s)');
    
    try {
      for (const document of documents) {
        {{functionBody}}
      }
      
      {{#if outputBindings}}
      {{#each outputBindings}}
      context.extraOutputs.set({{camelCase name}}Output, {{outputValue}});
      {{/each}}
      {{/if}}
      
      context.log('{{functionName}} completed successfully');
    } catch (error) {
      context.error('Error processing Cosmos DB documents:', error);
      throw error;
    }
  }
});
{{/if}}

{{#if triggerType === 'serviceBus'}}
app.serviceBus{{#if isQueue}}Queue{{else}}Topic{{/if}}('{{functionName}}', {
  {{#if isQueue}}
  queueName: '{{queueName}}',
  {{else}}
  topicName: '{{topicName}}',
  subscriptionName: '{{subscriptionName}}',
  {{/if}}
  connection: '{{connectionSetting}}',
  {{#if outputBindings}}
  extraOutputs: [{{#each outputBindings}}{{camelCase name}}Output{{#unless @last}}, {{/unless}}{{/each}}],
  {{/if}}
  handler: async (message, context) => {
    context.log('{{functionName}} processed Service Bus message:', message);
    
    try {
      {{functionBody}}
      
      {{#if outputBindings}}
      {{#each outputBindings}}
      context.extraOutputs.set({{camelCase name}}Output, {{outputValue}});
      {{/each}}
      {{/if}}
      
      context.log('{{functionName}} completed successfully');
    } catch (error) {
      context.error('Error processing Service Bus message:', error);
      throw error;
    }
  }
});
{{/if}}

{{#if triggerType === 'eventHub'}}
app.eventHub('{{functionName}}', {
  eventHubName: '{{eventHubName}}',
  connection: '{{connectionSetting}}',
  {{#if consumerGroup}}
  consumerGroup: '{{consumerGroup}}',
  {{/if}}
  {{#if cardinality}}
  cardinality: '{{cardinality}}',
  {{/if}}
  {{#if outputBindings}}
  extraOutputs: [{{#each outputBindings}}{{camelCase name}}Output{{#unless @last}}, {{/unless}}{{/each}}],
  {{/if}}
  handler: async (events, context) => {
    const eventArray = Array.isArray(events) ? events : [events];
    context.log('{{functionName}} processed', eventArray.length, 'event(s)');
    
    try {
      for (const event of eventArray) {
        {{functionBody}}
      }
      
      {{#if outputBindings}}
      {{#each outputBindings}}
      context.extraOutputs.set({{camelCase name}}Output, {{outputValue}});
      {{/each}}
      {{/if}}
      
      context.log('{{functionName}} completed successfully');
    } catch (error) {
      context.error('Error processing Event Hub events:', error);
      throw error;
    }
  }
});
{{/if}}

{{else}}
// JavaScript version
const { app{{#if outputBindings}}, output{{/if}} } = require('@azure/functions');
{{#if customImports}}
{{#each customImports}}
const {{#if default}}{{default}}{{else}}{ {{named}} }{{/if}} = require('{{from}}');
{{/each}}
{{/if}}

{{#if outputBindings}}
// Output bindings
{{#each outputBindings}}
const {{camelCase name}}Output = output.{{type}}({
{{#each config}}
  {{key}}: '{{value}}',
{{/each}}
});
{{/each}}
{{/if}}

app.{{triggerMethod}}('{{functionName}}', {
  {{triggerConfig}},
  {{#if outputBindings}}
  extraOutputs: [{{#each outputBindings}}{{camelCase name}}Output{{#unless @last}}, {{/unless}}{{/each}}],
  {{/if}}
  handler: async ({{triggerParam}}, context) => {
    context.log('{{functionName}} function triggered');
    
    try {
      {{functionBody}}
      
      {{#if outputBindings}}
      {{#each outputBindings}}
      context.extraOutputs.set({{camelCase name}}Output, {{outputValue}});
      {{/each}}
      {{/if}}
      
      {{#if httpTrigger}}
      return {
        status: 200,
        jsonBody: {{responseBody}}
      };
      {{/if}}
    } catch (error) {
      context.error('Error in {{functionName}}:', error);
      {{#if httpTrigger}}
      return { status: 500, body: 'Internal server error' };
      {{else}}
      throw error;
      {{/if}}
    }
  }
});
{{/if}}
