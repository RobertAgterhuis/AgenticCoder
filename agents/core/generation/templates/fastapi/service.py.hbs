"""
{{pascalCase name}} Service
{{description}}

Business logic for {{name}} operations
"""

from typing import List, Optional
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from sqlalchemy.orm import selectinload

from app.models.{{snakeCase name}} import {{pascalCase name}}
from app.schemas.{{snakeCase name}} import {{pascalCase name}}Create, {{pascalCase name}}Update
{{#if imports}}
{{#each imports}}
from {{this.from}} import {{this.items}}
{{/each}}
{{/if}}


class {{pascalCase name}}Service:
    """
    Service class for {{name}} operations
    """
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        {{#each filters}}
        {{name}}: Optional[{{pythonType}}] = None,
        {{/each}}
    ) -> tuple[List[{{pascalCase name}}], int]:
        """
        Get all {{name}}s with optional filtering
        """
        query = select({{pascalCase name}})
        count_query = select(func.count({{pascalCase name}}.id))
        
        {{#each filters}}
        if {{name}} is not None:
            query = query.where({{pascalCase ../name}}.{{name}} == {{name}})
            count_query = count_query.where({{pascalCase ../name}}.{{name}} == {{name}})
        {{/each}}
        
        {{#if includes}}
        query = query.options(
            {{#each includes}}
            selectinload({{pascalCase ../name}}.{{this}}),
            {{/each}}
        )
        {{/if}}
        
        query = query.offset(skip).limit(limit).order_by({{pascalCase name}}.created_at.desc())
        
        result = await self.db.execute(query)
        count_result = await self.db.execute(count_query)
        
        return result.scalars().all(), count_result.scalar()
    
    async def get_by_id(self, id: UUID) -> Optional[{{pascalCase name}}]:
        """
        Get {{name}} by ID
        """
        query = select({{pascalCase name}}).where({{pascalCase name}}.id == id)
        {{#if includes}}
        query = query.options(
            {{#each includes}}
            selectinload({{pascalCase ../name}}.{{this}}),
            {{/each}}
        )
        {{/if}}
        result = await self.db.execute(query)
        return result.scalar_one_or_none()
    
    async def create(self, data: {{pascalCase name}}Create) -> {{pascalCase name}}:
        """
        Create new {{name}}
        """
        db_obj = {{pascalCase name}}(**data.model_dump())
        self.db.add(db_obj)
        await self.db.commit()
        await self.db.refresh(db_obj)
        return db_obj
    
    async def update(self, id: UUID, data: {{pascalCase name}}Update) -> Optional[{{pascalCase name}}]:
        """
        Update existing {{name}}
        """
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return None
        
        update_data = data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_obj, field, value)
        
        await self.db.commit()
        await self.db.refresh(db_obj)
        return db_obj
    
    async def delete(self, id: UUID) -> bool:
        """
        Delete {{name}} by ID
        """
        db_obj = await self.get_by_id(id)
        if not db_obj:
            return False
        
        await self.db.delete(db_obj)
        await self.db.commit()
        return True
    
    {{#each customMethods}}
    async def {{name}}(self{{#if params}}, {{#each params}}{{name}}: {{pythonType}}{{#unless @last}}, {{/unless}}{{/each}}{{/if}}) -> {{returnType}}:
        """
        {{description}}
        """
        {{body}}
    {{/each}}
