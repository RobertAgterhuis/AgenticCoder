/**
 * PostgreSQLGenerator - Generates database-related code
 * 
 * Produces:
 * - Prisma schema with models and relations
 * - Migration files
 * - Seed data scripts
 * - Database utility functions
 */

const BaseGenerator = require('./BaseGenerator');

class PostgreSQLGenerator extends BaseGenerator {
  /**
   * @param {Object} templateRegistry - Template registry instance
   * @param {Object} promptComposer - Prompt composer instance
   */
  constructor(templateRegistry, promptComposer) {
    super('postgresql', { database: 'postgresql', orm: 'prisma' });
    this.templateRegistry = templateRegistry;
    this.promptComposer = promptComposer;
  }

  /**
   * Check if this generator supports the given tech stack
   */
  supports(techStack) {
    const database = techStack.database;
    return database && (
      database.type === 'postgresql' ||
      database.type === 'postgres'
    );
  }

  /**
   * Priority - Database generator runs after backend
   */
  get priority() {
    return 80;
  }

  /**
   * Generate all PostgreSQL/Prisma files
   */
  async generate(context) {
    const files = [];
    const requirements = context.requirements;
    const entities = requirements.entities || [];

    // Generate Prisma schema
    files.push(await this.generatePrismaSchema(context, entities));

    // Generate seed file
    if (requirements.seedData !== false) {
      files.push(await this.generateSeedFile(context, entities));
    }

    // Generate database utilities
    files.push(await this.generateDbUtils(context));

    // Generate validators for each entity
    for (const entity of entities) {
      files.push(await this.generateValidator(context, entity));
    }
    files.push(await this.generateValidatorsIndex(context, entities));

    return files;
  }

  /**
   * Generate Prisma schema file
   */
  async generatePrismaSchema(context, entities) {
    let schema = `// Prisma Schema
// Generated by AgenticCoder

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

`;

    // Add models for each entity
    for (const entity of entities) {
      schema += this.generatePrismaModel(entity);
      schema += '\n';
    }

    return this.createFile('backend/prisma/schema.prisma', schema, 'schema');
  }

  /**
   * Generate a single Prisma model
   */
  generatePrismaModel(entity) {
    const name = this.toPascalCase(entity.name);
    const fields = entity.fields || [];
    
    let model = `model ${name} {\n`;
    
    // ID field
    model += `  id        String   @id @default(cuid())\n`;
    
    // Entity fields
    for (const field of fields) {
      model += this.generatePrismaField(field);
    }
    
    // Timestamps
    model += `  createdAt DateTime @default(now())\n`;
    model += `  updatedAt DateTime @updatedAt\n`;
    
    // Relations
    if (entity.relations) {
      model += '\n';
      for (const relation of entity.relations) {
        model += this.generatePrismaRelation(relation);
      }
    }
    
    // Indexes
    if (entity.indexes) {
      model += '\n';
      for (const index of entity.indexes) {
        const fields = Array.isArray(index.fields) 
          ? index.fields.join(', ') 
          : index.fields;
        model += `  @@index([${fields}])\n`;
      }
    }
    
    model += `}\n`;
    return model;
  }

  /**
   * Generate a Prisma field
   */
  generatePrismaField(field) {
    const prismaType = this.mapToPrismaType(field.type);
    const optional = field.required ? '' : '?';
    const unique = field.unique ? ' @unique' : '';
    const defaultVal = field.default !== undefined 
      ? ` @default(${this.formatPrismaDefault(field.default, field.type)})` 
      : '';
    
    return `  ${field.name.padEnd(12)} ${prismaType}${optional}${unique}${defaultVal}\n`;
  }

  /**
   * Generate a Prisma relation
   */
  generatePrismaRelation(relation) {
    const { name, type, target, fields, references, onDelete } = relation;
    
    if (type === 'one-to-many' || type === 'many-to-one') {
      const deleteAction = onDelete ? ` onDelete: ${onDelete}` : '';
      return `  ${name.padEnd(12)} ${target}${type === 'many-to-one' ? '' : '[]'}${fields ? ` @relation(fields: [${fields}], references: [${references}]${deleteAction})` : ''}\n`;
    } else if (type === 'many-to-many') {
      return `  ${name.padEnd(12)} ${target}[]\n`;
    }
    return '';
  }

  /**
   * Map JavaScript/TypeScript types to Prisma types
   */
  mapToPrismaType(jsType) {
    const typeMap = {
      'string': 'String',
      'String': 'String',
      'number': 'Int',
      'Number': 'Int',
      'int': 'Int',
      'integer': 'Int',
      'float': 'Float',
      'Float': 'Float',
      'double': 'Float',
      'decimal': 'Decimal',
      'Decimal': 'Decimal',
      'boolean': 'Boolean',
      'Boolean': 'Boolean',
      'bool': 'Boolean',
      'date': 'DateTime',
      'Date': 'DateTime',
      'datetime': 'DateTime',
      'DateTime': 'DateTime',
      'json': 'Json',
      'Json': 'Json',
      'object': 'Json',
      'text': 'String',
      'uuid': 'String',
    };
    
    return typeMap[jsType] || 'String';
  }

  /**
   * Format default value for Prisma
   */
  formatPrismaDefault(value, type) {
    if (typeof value === 'string') {
      if (value === 'now()' || value === 'cuid()' || value === 'uuid()' || value === 'autoincrement()') {
        return value;
      }
      return `"${value}"`;
    }
    if (typeof value === 'boolean') {
      return value.toString();
    }
    return value;
  }

  /**
   * Generate seed file
   */
  async generateSeedFile(context, entities) {
    let imports = `import { PrismaClient } from '@prisma/client';\n\n`;
    let seedFunctions = '';
    let mainFunction = `async function main() {\n  const prisma = new PrismaClient();\n\n  try {\n`;
    
    for (const entity of entities) {
      const name = this.toCamelCase(entity.name);
      const Name = this.toPascalCase(entity.name);
      
      seedFunctions += this.generateEntitySeed(entity);
      mainFunction += `    console.log('Seeding ${name}s...');\n`;
      mainFunction += `    await seed${Name}s(prisma);\n\n`;
    }
    
    mainFunction += `    console.log('Seeding complete!');\n`;
    mainFunction += `  } catch (error) {\n`;
    mainFunction += `    console.error('Seeding failed:', error);\n`;
    mainFunction += `    throw error;\n`;
    mainFunction += `  } finally {\n`;
    mainFunction += `    await prisma.$disconnect();\n`;
    mainFunction += `  }\n}\n\nmain();\n`;

    const content = imports + seedFunctions + mainFunction;
    return this.createFile('backend/prisma/seed.ts', content, 'seed');
  }

  /**
   * Generate seed function for an entity
   */
  generateEntitySeed(entity) {
    const name = this.toCamelCase(entity.name);
    const Name = this.toPascalCase(entity.name);
    const fields = entity.fields || [];
    
    let seedData = '{';
    for (const field of fields) {
      if (!field.generated && field.name !== 'id') {
        seedData += `\n      ${field.name}: ${this.getSampleValue(field)},`;
      }
    }
    seedData += '\n    }';

    return `
async function seed${Name}s(prisma: PrismaClient) {
  const data = [
    ${seedData},
  ];

  for (const item of data) {
    await prisma.${name}.create({ data: item });
  }
}
`;
  }

  /**
   * Get sample value for a field type
   */
  getSampleValue(field) {
    const type = field.type.toLowerCase();
    const name = field.name.toLowerCase();
    
    // Handle specific field names
    if (name.includes('email')) return "'user@example.com'";
    if (name.includes('name')) return "'Sample Name'";
    if (name.includes('title')) return "'Sample Title'";
    if (name.includes('description')) return "'Sample description text'";
    if (name.includes('url') || name.includes('link')) return "'https://example.com'";
    if (name.includes('phone')) return "'+1234567890'";
    if (name.includes('price') || name.includes('amount')) return "99.99";
    
    // Handle by type
    switch (type) {
      case 'string':
      case 'text':
        return "'Sample text'";
      case 'number':
      case 'int':
      case 'integer':
        return "1";
      case 'float':
      case 'double':
      case 'decimal':
        return "1.0";
      case 'boolean':
      case 'bool':
        return "true";
      case 'date':
      case 'datetime':
        return "new Date()";
      case 'json':
      case 'object':
        return "{}";
      default:
        return "'sample'";
    }
  }

  /**
   * Generate database utilities
   */
  async generateDbUtils(context) {
    const content = `import { PrismaClient, Prisma } from '@prisma/client';

/**
 * Create a transaction with error handling
 */
export async function withTransaction<T>(
  prisma: PrismaClient,
  fn: (tx: Prisma.TransactionClient) => Promise<T>
): Promise<T> {
  return prisma.$transaction(fn);
}

/**
 * Pagination helper
 */
export interface PaginationParams {
  page?: number;
  limit?: number;
}

export interface PaginatedResult<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export async function paginate<T>(
  model: any,
  params: PaginationParams,
  where: any = {}
): Promise<PaginatedResult<T>> {
  const page = params.page || 1;
  const limit = params.limit || 10;
  const skip = (page - 1) * limit;

  const [data, total] = await Promise.all([
    model.findMany({
      where,
      skip,
      take: limit,
    }),
    model.count({ where }),
  ]);

  return {
    data,
    meta: {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    },
  };
}

/**
 * Soft delete helper
 */
export function softDeleteMiddleware(): Prisma.Middleware {
  return async (params, next) => {
    if (params.action === 'delete') {
      params.action = 'update';
      params.args.data = { deletedAt: new Date() };
    }
    if (params.action === 'deleteMany') {
      params.action = 'updateMany';
      if (params.args.data !== undefined) {
        params.args.data.deletedAt = new Date();
      } else {
        params.args.data = { deletedAt: new Date() };
      }
    }
    return next(params);
  };
}

/**
 * Query timing logger
 */
export function queryLogger(): Prisma.Middleware {
  return async (params, next) => {
    const before = Date.now();
    const result = await next(params);
    const after = Date.now();
    console.log(\`Query \${params.model}.\${params.action} took \${after - before}ms\`);
    return result;
  };
}
`;
    return this.createFile('backend/src/utils/db.utils.ts', content, 'utility');
  }

  /**
   * Generate validator for an entity
   */
  async generateValidator(context, entity) {
    const name = this.toCamelCase(entity.name);
    const fields = entity.fields || [];

    let createSchema = '';
    let updateSchema = '';

    for (const field of fields) {
      if (!field.generated && field.name !== 'id') {
        const zodType = this.mapToZodType(field);
        const optional = field.required ? '' : '.optional()';
        createSchema += `  ${field.name}: ${zodType}${optional},\n`;
        updateSchema += `  ${field.name}: ${zodType}.optional(),\n`;
      }
    }

    const content = `import { z } from 'zod';

export const ${name}Schema = {
  create: z.object({
${createSchema}  }),

  update: z.object({
${updateSchema}  }),

  id: z.object({
    id: z.string().cuid(),
  }),
};

export type Create${this.toPascalCase(entity.name)}Schema = z.infer<typeof ${name}Schema.create>;
export type Update${this.toPascalCase(entity.name)}Schema = z.infer<typeof ${name}Schema.update>;
`;
    return this.createFile(`backend/src/validators/${name}.validator.ts`, content, 'validator');
  }

  /**
   * Map field to Zod type
   */
  mapToZodType(field) {
    const type = field.type.toLowerCase();
    const name = field.name.toLowerCase();

    // Special handling for common field names
    if (name.includes('email')) return 'z.string().email()';
    if (name.includes('url') || name.includes('link')) return 'z.string().url()';
    if (name.includes('uuid')) return 'z.string().uuid()';

    switch (type) {
      case 'string':
      case 'text':
        return field.minLength || field.maxLength
          ? `z.string()${field.minLength ? `.min(${field.minLength})` : ''}${field.maxLength ? `.max(${field.maxLength})` : ''}`
          : 'z.string()';
      case 'number':
      case 'int':
      case 'integer':
        return 'z.number().int()';
      case 'float':
      case 'double':
      case 'decimal':
        return 'z.number()';
      case 'boolean':
      case 'bool':
        return 'z.boolean()';
      case 'date':
      case 'datetime':
        return 'z.coerce.date()';
      case 'json':
      case 'object':
        return 'z.record(z.any())';
      case 'array':
        return 'z.array(z.any())';
      default:
        return 'z.string()';
    }
  }

  /**
   * Generate validators index
   */
  async generateValidatorsIndex(context, entities) {
    let exports = '';
    for (const entity of entities) {
      const name = this.toCamelCase(entity.name);
      exports += `export * from './${name}.validator';\n`;
    }
    return this.createFile('backend/src/validators/index.ts', exports, 'index');
  }
}

module.exports = PostgreSQLGenerator;
