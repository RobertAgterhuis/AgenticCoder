/**
 * ContainerAppsGenerator - Azure Container Apps Generator
 * 
 * Generates Container Apps configurations, environment settings,
 * and related infrastructure.
 */

const BaseGenerator = require('./BaseGenerator');

class ContainerAppsGenerator extends BaseGenerator {
  constructor(options = {}) {
    super({
      name: 'ContainerAppsGenerator',
      framework: 'azure-container-apps',
      version: '2023-05-01',
      language: 'bicep',
      ...options
    });
    
    this.templatePath = 'azure/containerApps';
    this.supportedTypes = ['app', 'environment', 'job', 'dapr'];
  }

  /**
   * Generate Container App configuration
   */
  async generateApp(context) {
    const { 
      name,
      environmentId,
      image,
      targetPort = 8080,
      ingress = true,
      external = true,
      minReplicas = 0,
      maxReplicas = 10,
      cpu = '0.5',
      memory = '1Gi',
      env = [],
      secrets = [],
      volumes = [],
      probes = {},
      dapr,
      location = 'eastus',
      tags = {}
    } = context;
    
    const templateData = {
      name: this.toKebabCase(name),
      environmentId,
      image,
      targetPort,
      ingress,
      external,
      minReplicas,
      maxReplicas,
      cpu,
      memory,
      env: this.buildEnvVars(env),
      secrets: this.buildSecrets(secrets),
      volumes: this.buildVolumes(volumes),
      probes: this.buildProbes(probes),
      dapr: this.buildDaprConfig(dapr),
      location,
      tags
    };
    
    return this.generateAppBicep(templateData);
  }

  /**
   * Generate Container Apps Environment
   */
  async generateEnvironment(context) {
    const { 
      name,
      logAnalyticsWorkspaceId,
      infrastructureSubnetId,
      internal = false,
      zoneRedundant = false,
      daprAIConnectionString,
      location = 'eastus',
      tags = {}
    } = context;
    
    const templateData = {
      name: this.toKebabCase(name),
      logAnalyticsWorkspaceId,
      infrastructureSubnetId,
      internal,
      zoneRedundant,
      daprAIConnectionString,
      location,
      tags
    };
    
    return this.generateEnvironmentBicep(templateData);
  }

  /**
   * Generate Container App Job
   */
  async generateJob(context) {
    const { 
      name,
      environmentId,
      image,
      triggerType = 'Schedule',
      cronExpression = '0 0 * * *',
      cpu = '0.5',
      memory = '1Gi',
      env = [],
      secrets = [],
      parallelism = 1,
      replicaCompletionCount = 1,
      replicaRetryLimit = 3,
      replicaTimeout = 1800,
      location = 'eastus',
      tags = {}
    } = context;
    
    const templateData = {
      name: this.toKebabCase(name),
      environmentId,
      image,
      triggerType,
      cronExpression,
      cpu,
      memory,
      env: this.buildEnvVars(env),
      secrets: this.buildSecrets(secrets),
      parallelism,
      replicaCompletionCount,
      replicaRetryLimit,
      replicaTimeout,
      location,
      tags
    };
    
    return this.generateJobBicep(templateData);
  }

  /**
   * Generate Dapr component configuration
   */
  async generateDapr(context) {
    const { 
      name,
      type,
      version = 'v1',
      metadata = [],
      scopes = []
    } = context;
    
    const templateData = {
      name: this.toKebabCase(name),
      type,
      version,
      metadata,
      scopes
    };
    
    return this.generateDaprComponent(templateData);
  }

  // Bicep generators
  generateAppBicep(data) {
    const lines = [];
    
    lines.push('// Azure Container App');
    lines.push('// Generated by AgenticCoder');
    lines.push('');
    lines.push('@description(\'Name of the Container App\')');
    lines.push(`param containerAppName string = '${data.name}'`);
    lines.push('');
    lines.push('@description(\'Container Apps Environment ID\')');
    lines.push('param containerAppsEnvironmentId string');
    lines.push('');
    lines.push('@description(\'Container image to deploy\')');
    lines.push(`param containerImage string = '${data.image}'`);
    lines.push('');
    lines.push('@description(\'Location for the Container App\')');
    lines.push(`param location string = '${data.location}'`);
    lines.push('');
    lines.push('@description(\'Tags for the resources\')');
    lines.push(`param tags object = ${JSON.stringify(data.tags)}`);
    lines.push('');
    
    // Secrets parameters
    if (data.secrets.length) {
      lines.push('@secure()');
      lines.push('@description(\'Secrets for the Container App\')');
      lines.push('param secrets object = {}');
      lines.push('');
    }
    
    lines.push('resource containerApp \'Microsoft.App/containerApps@2023-05-01\' = {');
    lines.push('  name: containerAppName');
    lines.push('  location: location');
    lines.push('  tags: tags');
    lines.push('  properties: {');
    lines.push('    managedEnvironmentId: containerAppsEnvironmentId');
    lines.push('    configuration: {');
    
    // Ingress
    if (data.ingress) {
      lines.push('      ingress: {');
      lines.push(`        external: ${data.external}`);
      lines.push(`        targetPort: ${data.targetPort}`);
      lines.push('        transport: \'auto\'');
      lines.push('        allowInsecure: false');
      lines.push('        traffic: [');
      lines.push('          {');
      lines.push('            weight: 100');
      lines.push('            latestRevision: true');
      lines.push('          }');
      lines.push('        ]');
      lines.push('      }');
    }
    
    // Dapr
    if (data.dapr) {
      lines.push('      dapr: {');
      lines.push(`        enabled: true`);
      lines.push(`        appId: '${data.dapr.appId || data.name}'`);
      lines.push(`        appPort: ${data.dapr.appPort || data.targetPort}`);
      lines.push(`        appProtocol: '${data.dapr.appProtocol || 'http'}'`);
      lines.push('      }');
    }
    
    // Secrets
    if (data.secrets.length) {
      lines.push('      secrets: [');
      for (const secret of data.secrets) {
        lines.push('        {');
        lines.push(`          name: '${secret.name}'`);
        if (secret.keyVaultUrl) {
          lines.push(`          keyVaultUrl: '${secret.keyVaultUrl}'`);
          lines.push(`          identity: '${secret.identity || 'system'}'`);
        } else {
          lines.push(`          value: secrets.${secret.name}`);
        }
        lines.push('        }');
      }
      lines.push('      ]');
    }
    
    lines.push('    }');
    lines.push('    template: {');
    lines.push('      containers: [');
    lines.push('        {');
    lines.push('          name: containerAppName');
    lines.push('          image: containerImage');
    lines.push('          resources: {');
    lines.push(`            cpu: json('${data.cpu}')`);
    lines.push(`            memory: '${data.memory}'`);
    lines.push('          }');
    
    // Environment variables
    if (data.env.length) {
      lines.push('          env: [');
      for (const env of data.env) {
        lines.push('            {');
        lines.push(`              name: '${env.name}'`);
        if (env.secretRef) {
          lines.push(`              secretRef: '${env.secretRef}'`);
        } else {
          lines.push(`              value: '${env.value}'`);
        }
        lines.push('            }');
      }
      lines.push('          ]');
    }
    
    // Probes
    if (data.probes.liveness) {
      lines.push('          probes: [');
      lines.push('            {');
      lines.push("              type: 'Liveness'");
      lines.push('              httpGet: {');
      lines.push(`                path: '${data.probes.liveness.path || '/health'}'`);
      lines.push(`                port: ${data.probes.liveness.port || data.targetPort}`);
      lines.push('              }');
      lines.push(`              initialDelaySeconds: ${data.probes.liveness.initialDelay || 10}`);
      lines.push(`              periodSeconds: ${data.probes.liveness.period || 10}`);
      lines.push('            }');
      
      if (data.probes.readiness) {
        lines.push('            {');
        lines.push("              type: 'Readiness'");
        lines.push('              httpGet: {');
        lines.push(`                path: '${data.probes.readiness.path || '/ready'}'`);
        lines.push(`                port: ${data.probes.readiness.port || data.targetPort}`);
        lines.push('              }');
        lines.push(`              initialDelaySeconds: ${data.probes.readiness.initialDelay || 5}`);
        lines.push(`              periodSeconds: ${data.probes.readiness.period || 5}`);
        lines.push('            }');
      }
      
      lines.push('          ]');
    }
    
    // Volumes
    if (data.volumes.length) {
      lines.push('          volumeMounts: [');
      for (const vol of data.volumes) {
        lines.push('            {');
        lines.push(`              volumeName: '${vol.name}'`);
        lines.push(`              mountPath: '${vol.mountPath}'`);
        lines.push('            }');
      }
      lines.push('          ]');
    }
    
    lines.push('        }');
    lines.push('      ]');
    
    // Scale
    lines.push('      scale: {');
    lines.push(`        minReplicas: ${data.minReplicas}`);
    lines.push(`        maxReplicas: ${data.maxReplicas}`);
    lines.push('        rules: [');
    lines.push('          {');
    lines.push("            name: 'http-scaling'");
    lines.push('            http: {');
    lines.push('              metadata: {');
    lines.push("                concurrentRequests: '100'");
    lines.push('              }');
    lines.push('            }');
    lines.push('          }');
    lines.push('        ]');
    lines.push('      }');
    
    // Volumes definition
    if (data.volumes.length) {
      lines.push('      volumes: [');
      for (const vol of data.volumes) {
        lines.push('        {');
        lines.push(`          name: '${vol.name}'`);
        lines.push(`          storageType: '${vol.storageType || 'AzureFile'}'`);
        if (vol.storageName) {
          lines.push(`          storageName: '${vol.storageName}'`);
        }
        lines.push('        }');
      }
      lines.push('      ]');
    }
    
    lines.push('    }');
    lines.push('  }');
    lines.push('}');
    lines.push('');
    
    // Outputs
    lines.push('output containerAppId string = containerApp.id');
    lines.push('output containerAppName string = containerApp.name');
    lines.push('output containerAppFqdn string = containerApp.properties.configuration.ingress.fqdn');
    
    return lines.join('\n');
  }

  generateEnvironmentBicep(data) {
    const lines = [];
    
    lines.push('// Azure Container Apps Environment');
    lines.push('// Generated by AgenticCoder');
    lines.push('');
    lines.push('@description(\'Name of the Container Apps Environment\')');
    lines.push(`param environmentName string = '${data.name}'`);
    lines.push('');
    lines.push('@description(\'Location for the environment\')');
    lines.push(`param location string = '${data.location}'`);
    lines.push('');
    lines.push('@description(\'Log Analytics Workspace ID\')');
    lines.push('param logAnalyticsWorkspaceId string');
    lines.push('');
    
    if (data.infrastructureSubnetId) {
      lines.push('@description(\'Subnet ID for infrastructure\')');
      lines.push('param infrastructureSubnetId string');
      lines.push('');
    }
    
    lines.push('@description(\'Tags for the resources\')');
    lines.push(`param tags object = ${JSON.stringify(data.tags)}`);
    lines.push('');
    
    // Get Log Analytics details
    lines.push("resource logAnalytics 'Microsoft.OperationalInsights/workspaces@2022-10-01' existing = {");
    lines.push('  name: last(split(logAnalyticsWorkspaceId, \'/\'))');
    lines.push('}');
    lines.push('');
    
    lines.push('resource environment \'Microsoft.App/managedEnvironments@2023-05-01\' = {');
    lines.push('  name: environmentName');
    lines.push('  location: location');
    lines.push('  tags: tags');
    lines.push('  properties: {');
    
    if (data.infrastructureSubnetId) {
      lines.push('    vnetConfiguration: {');
      lines.push('      infrastructureSubnetId: infrastructureSubnetId');
      lines.push(`      internal: ${data.internal}`);
      lines.push('    }');
    }
    
    lines.push('    appLogsConfiguration: {');
    lines.push("      destination: 'log-analytics'");
    lines.push('      logAnalyticsConfiguration: {');
    lines.push('        customerId: logAnalytics.properties.customerId');
    lines.push('        sharedKey: logAnalytics.listKeys().primarySharedKey');
    lines.push('      }');
    lines.push('    }');
    
    if (data.zoneRedundant) {
      lines.push('    zoneRedundant: true');
    }
    
    if (data.daprAIConnectionString) {
      lines.push('    daprAIConnectionString: daprAIConnectionString');
    }
    
    lines.push('  }');
    lines.push('}');
    lines.push('');
    
    lines.push('output environmentId string = environment.id');
    lines.push('output environmentName string = environment.name');
    lines.push('output defaultDomain string = environment.properties.defaultDomain');
    
    return lines.join('\n');
  }

  generateJobBicep(data) {
    const lines = [];
    
    lines.push('// Azure Container Apps Job');
    lines.push('// Generated by AgenticCoder');
    lines.push('');
    lines.push('@description(\'Name of the Container App Job\')');
    lines.push(`param jobName string = '${data.name}'`);
    lines.push('');
    lines.push('@description(\'Container Apps Environment ID\')');
    lines.push('param containerAppsEnvironmentId string');
    lines.push('');
    lines.push('@description(\'Container image to deploy\')');
    lines.push(`param containerImage string = '${data.image}'`);
    lines.push('');
    lines.push('@description(\'Location for the Container App Job\')');
    lines.push(`param location string = '${data.location}'`);
    lines.push('');
    lines.push('@description(\'Tags for the resources\')');
    lines.push(`param tags object = ${JSON.stringify(data.tags)}`);
    lines.push('');
    
    lines.push('resource job \'Microsoft.App/jobs@2023-05-01\' = {');
    lines.push('  name: jobName');
    lines.push('  location: location');
    lines.push('  tags: tags');
    lines.push('  properties: {');
    lines.push('    environmentId: containerAppsEnvironmentId');
    lines.push('    configuration: {');
    lines.push(`      triggerType: '${data.triggerType}'`);
    
    if (data.triggerType === 'Schedule') {
      lines.push('      scheduleTriggerConfig: {');
      lines.push(`        cronExpression: '${data.cronExpression}'`);
      lines.push(`        parallelism: ${data.parallelism}`);
      lines.push(`        replicaCompletionCount: ${data.replicaCompletionCount}`);
      lines.push('      }');
    } else if (data.triggerType === 'Manual') {
      lines.push('      manualTriggerConfig: {');
      lines.push(`        parallelism: ${data.parallelism}`);
      lines.push(`        replicaCompletionCount: ${data.replicaCompletionCount}`);
      lines.push('      }');
    }
    
    lines.push(`      replicaRetryLimit: ${data.replicaRetryLimit}`);
    lines.push(`      replicaTimeout: ${data.replicaTimeout}`);
    
    if (data.secrets.length) {
      lines.push('      secrets: [');
      for (const secret of data.secrets) {
        lines.push('        {');
        lines.push(`          name: '${secret.name}'`);
        lines.push(`          value: '${secret.value}'`);
        lines.push('        }');
      }
      lines.push('      ]');
    }
    
    lines.push('    }');
    lines.push('    template: {');
    lines.push('      containers: [');
    lines.push('        {');
    lines.push('          name: jobName');
    lines.push('          image: containerImage');
    lines.push('          resources: {');
    lines.push(`            cpu: json('${data.cpu}')`);
    lines.push(`            memory: '${data.memory}'`);
    lines.push('          }');
    
    if (data.env.length) {
      lines.push('          env: [');
      for (const env of data.env) {
        lines.push('            {');
        lines.push(`              name: '${env.name}'`);
        if (env.secretRef) {
          lines.push(`              secretRef: '${env.secretRef}'`);
        } else {
          lines.push(`              value: '${env.value}'`);
        }
        lines.push('            }');
      }
      lines.push('          ]');
    }
    
    lines.push('        }');
    lines.push('      ]');
    lines.push('    }');
    lines.push('  }');
    lines.push('}');
    lines.push('');
    
    lines.push('output jobId string = job.id');
    lines.push('output jobName string = job.name');
    
    return lines.join('\n');
  }

  generateDaprComponent(data) {
    const component = {
      componentType: data.type,
      version: data.version,
      metadata: data.metadata.map(m => ({
        name: m.name,
        value: m.value,
        secretRef: m.secretRef
      })),
      scopes: data.scopes
    };
    
    return JSON.stringify(component, null, 2);
  }

  // Helper methods
  buildEnvVars(env) {
    return env.map(e => ({
      name: e.name,
      value: e.value,
      secretRef: e.secretRef
    }));
  }

  buildSecrets(secrets) {
    return secrets.map(s => ({
      name: s.name,
      value: s.value,
      keyVaultUrl: s.keyVaultUrl,
      identity: s.identity
    }));
  }

  buildVolumes(volumes) {
    return volumes.map(v => ({
      name: v.name,
      mountPath: v.mountPath,
      storageType: v.storageType || 'AzureFile',
      storageName: v.storageName
    }));
  }

  buildProbes(probes) {
    return {
      liveness: probes.liveness ? {
        path: probes.liveness.path || '/health',
        port: probes.liveness.port,
        initialDelay: probes.liveness.initialDelay || 10,
        period: probes.liveness.period || 10
      } : null,
      readiness: probes.readiness ? {
        path: probes.readiness.path || '/ready',
        port: probes.readiness.port,
        initialDelay: probes.readiness.initialDelay || 5,
        period: probes.readiness.period || 5
      } : null
    };
  }

  buildDaprConfig(dapr) {
    if (!dapr) return null;
    return {
      enabled: true,
      appId: dapr.appId,
      appPort: dapr.appPort,
      appProtocol: dapr.appProtocol || 'http'
    };
  }
}

module.exports = ContainerAppsGenerator;
