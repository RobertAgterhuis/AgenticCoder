/**
 * SQLServerGenerator - SQL Server Code Generator
 * 
 * Generates SQL Server schemas, stored procedures, functions,
 * triggers, and migrations.
 */

const BaseGenerator = require('./BaseGenerator');

class SQLServerGenerator extends BaseGenerator {
  constructor(options = {}) {
    super({
      name: 'SQLServerGenerator',
      framework: 'sql-server',
      version: '2022',
      language: 'sql',
      ...options
    });
    
    this.templatePath = 'database/sql-server';
    this.supportedTypes = ['schema', 'storedProcedure', 'function', 'trigger', 'migration'];
  }

  /**
   * Generate a SQL Server table schema
   */
  async generateSchema(context) {
    const { 
      name, 
      schema = 'dbo',
      columns = [],
      primaryKey,
      foreignKeys = [],
      indexes = [],
      triggers = []
    } = context;
    
    const tableName = this.toPascalCase(name);
    
    const templateData = {
      tableName,
      schema,
      columns: this.buildColumns(columns),
      primaryKey: this.buildPrimaryKey(primaryKey, columns),
      foreignKeys: this.buildForeignKeys(foreignKeys),
      indexes: this.buildIndexes(indexes, tableName),
      triggers
    };
    
    return this.generateTableSql(templateData);
  }

  /**
   * Generate a SQL Server stored procedure
   */
  async generateStoredProcedure(context) {
    const { 
      name, 
      schema = 'dbo',
      parameters = [],
      body,
      errorHandling = true
    } = context;
    
    const procName = 'usp_' + this.toPascalCase(name);
    
    const templateData = {
      procName,
      schema,
      parameters: this.buildParameters(parameters),
      body: body || '-- TODO: implement',
      errorHandling
    };
    
    return this.generateProcedureSql(templateData);
  }

  /**
   * Generate a SQL Server function
   */
  async generateFunction(context) {
    const { 
      name, 
      schema = 'dbo',
      type = 'scalar',
      parameters = [],
      returnType,
      body
    } = context;
    
    const funcName = 'fn_' + this.toPascalCase(name);
    
    const templateData = {
      funcName,
      schema,
      type,
      parameters: this.buildParameters(parameters),
      returnType: returnType || 'INT',
      body: body || 'RETURN 0'
    };
    
    return this.generateFunctionSql(templateData);
  }

  /**
   * Generate a SQL Server trigger
   */
  async generateTrigger(context) {
    const { 
      name, 
      schema = 'dbo',
      table,
      timing = 'AFTER',
      events = ['INSERT'],
      body
    } = context;
    
    const triggerName = 'tr_' + this.toPascalCase(name);
    
    const templateData = {
      triggerName,
      schema,
      table,
      timing,
      events,
      body: body || '-- TODO: implement trigger logic'
    };
    
    return this.generateTriggerSql(templateData);
  }

  /**
   * Generate a SQL Server migration
   */
  async generateMigration(context) {
    const { 
      name, 
      version,
      up = [],
      down = []
    } = context;
    
    const templateData = {
      migrationName: `${version || this.getTimestamp()}_${this.toSnakeCase(name)}`,
      version: version || this.getTimestamp(),
      up: this.buildStatements(up),
      down: this.buildStatements(down)
    };
    
    return this.generateMigrationSql(templateData);
  }

  // SQL generation methods
  generateTableSql(data) {
    const lines = [];
    
    lines.push(`-- Table: [${data.schema}].[${data.tableName}]`);
    lines.push('-- Generated by AgenticCoder');
    lines.push('');
    
    lines.push(`IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = '${data.tableName}' AND schema_id = SCHEMA_ID('${data.schema}'))`);
    lines.push('BEGIN');
    lines.push(`    CREATE TABLE [${data.schema}].[${data.tableName}]`);
    lines.push('    (');
    
    const colDefs = data.columns.map(c => this.formatColumn(c));
    
    if (data.primaryKey) {
      colDefs.push(`        CONSTRAINT [PK_${data.tableName}] PRIMARY KEY ${data.primaryKey.clustered ? 'CLUSTERED' : 'NONCLUSTERED'} ([${data.primaryKey.columns.join('], [')}])`);
    }
    
    lines.push(colDefs.join(',\n'));
    lines.push('    );');
    lines.push('END');
    lines.push('GO');
    lines.push('');
    
    // Foreign keys
    for (const fk of data.foreignKeys) {
      lines.push(`IF NOT EXISTS (SELECT * FROM sys.foreign_keys WHERE name = 'FK_${data.tableName}_${fk.name}')`);
      lines.push('BEGIN');
      lines.push(`    ALTER TABLE [${data.schema}].[${data.tableName}]`);
      lines.push(`    ADD CONSTRAINT [FK_${data.tableName}_${fk.name}]`);
      lines.push(`    FOREIGN KEY ([${fk.column}]) REFERENCES [${fk.refSchema || data.schema}].[${fk.refTable}]([${fk.refColumn}])`);
      if (fk.onDelete) lines.push(`    ON DELETE ${fk.onDelete}`);
      if (fk.onUpdate) lines.push(`    ON UPDATE ${fk.onUpdate}`);
      lines.push(';');
      lines.push('END');
      lines.push('GO');
      lines.push('');
    }
    
    // Indexes
    for (const idx of data.indexes) {
      lines.push(`IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = '${idx.name}')`);
      lines.push('BEGIN');
      lines.push(`    CREATE ${idx.unique ? 'UNIQUE ' : ''}${idx.type || 'NONCLUSTERED'} INDEX [${idx.name}]`);
      lines.push(`    ON [${data.schema}].[${data.tableName}] ([${idx.columns.join('], [')}])`);
      if (idx.include?.length) {
        lines.push(`    INCLUDE ([${idx.include.join('], [')}])`);
      }
      if (idx.filter) {
        lines.push(`    WHERE ${idx.filter}`);
      }
      lines.push(';');
      lines.push('END');
      lines.push('GO');
      lines.push('');
    }
    
    return lines.join('\n');
  }

  generateProcedureSql(data) {
    const lines = [];
    
    lines.push(`-- Stored Procedure: [${data.schema}].[${data.procName}]`);
    lines.push('-- Generated by AgenticCoder');
    lines.push('');
    
    lines.push(`CREATE OR ALTER PROCEDURE [${data.schema}].[${data.procName}]`);
    
    if (data.parameters.length > 0) {
      const params = data.parameters.map(p => 
        `    @${p.name} ${p.type}${p.default !== undefined ? ` = ${p.default}` : ''}${p.output ? ' OUTPUT' : ''}`
      );
      lines.push(params.join(',\n'));
    }
    
    lines.push('AS');
    lines.push('BEGIN');
    lines.push('    SET NOCOUNT ON;');
    
    if (data.errorHandling) {
      lines.push('    SET XACT_ABORT ON;');
      lines.push('');
      lines.push('    BEGIN TRY');
      lines.push('        BEGIN TRANSACTION;');
      lines.push('');
      lines.push(`        ${data.body}`);
      lines.push('');
      lines.push('        COMMIT TRANSACTION;');
      lines.push('    END TRY');
      lines.push('    BEGIN CATCH');
      lines.push('        IF @@TRANCOUNT > 0');
      lines.push('            ROLLBACK TRANSACTION;');
      lines.push('');
      lines.push('        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();');
      lines.push('        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();');
      lines.push('        DECLARE @ErrorState INT = ERROR_STATE();');
      lines.push('');
      lines.push('        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);');
      lines.push('    END CATCH');
    } else {
      lines.push('');
      lines.push(`    ${data.body}`);
    }
    
    lines.push('END');
    lines.push('GO');
    
    return lines.join('\n');
  }

  generateFunctionSql(data) {
    const lines = [];
    
    lines.push(`-- Function: [${data.schema}].[${data.funcName}]`);
    lines.push('-- Generated by AgenticCoder');
    lines.push('');
    
    if (data.type === 'scalar') {
      lines.push(`CREATE OR ALTER FUNCTION [${data.schema}].[${data.funcName}]`);
      lines.push('(');
      
      if (data.parameters.length > 0) {
        const params = data.parameters.map(p => `    @${p.name} ${p.type}`);
        lines.push(params.join(',\n'));
      }
      
      lines.push(')');
      lines.push(`RETURNS ${data.returnType}`);
      lines.push('AS');
      lines.push('BEGIN');
      lines.push(`    ${data.body}`);
      lines.push('END');
    } else if (data.type === 'table') {
      lines.push(`CREATE OR ALTER FUNCTION [${data.schema}].[${data.funcName}]`);
      lines.push('(');
      
      if (data.parameters.length > 0) {
        const params = data.parameters.map(p => `    @${p.name} ${p.type}`);
        lines.push(params.join(',\n'));
      }
      
      lines.push(')');
      lines.push('RETURNS TABLE');
      lines.push('AS');
      lines.push('RETURN');
      lines.push('(');
      lines.push(`    ${data.body}`);
      lines.push(')');
    }
    
    lines.push('GO');
    
    return lines.join('\n');
  }

  generateTriggerSql(data) {
    const lines = [];
    
    lines.push(`-- Trigger: [${data.schema}].[${data.triggerName}]`);
    lines.push('-- Generated by AgenticCoder');
    lines.push('');
    
    lines.push(`CREATE OR ALTER TRIGGER [${data.schema}].[${data.triggerName}]`);
    lines.push(`ON [${data.schema}].[${data.table}]`);
    lines.push(`${data.timing} ${data.events.join(', ')}`);
    lines.push('AS');
    lines.push('BEGIN');
    lines.push('    SET NOCOUNT ON;');
    lines.push('');
    lines.push(`    ${data.body}`);
    lines.push('END');
    lines.push('GO');
    
    return lines.join('\n');
  }

  generateMigrationSql(data) {
    const lines = [];
    
    lines.push(`-- Migration: ${data.migrationName}`);
    lines.push('-- Generated by AgenticCoder');
    lines.push('');
    
    lines.push('-- ==========================================');
    lines.push('-- UP Migration');
    lines.push('-- ==========================================');
    lines.push('');
    
    for (const stmt of data.up) {
      lines.push(stmt);
      lines.push('GO');
      lines.push('');
    }
    
    lines.push('-- ==========================================');
    lines.push('-- DOWN Migration (Rollback)');
    lines.push('-- ==========================================');
    lines.push('/*');
    
    for (const stmt of data.down) {
      lines.push(stmt);
      lines.push('GO');
      lines.push('');
    }
    
    lines.push('*/');
    
    return lines.join('\n');
  }

  // Helper methods
  buildColumns(columns) {
    return columns.map(c => ({
      name: c.name,
      type: this.toSqlType(c.type, c),
      nullable: c.nullable !== false,
      identity: c.identity,
      default: c.default,
      computed: c.computed
    }));
  }

  formatColumn(col) {
    let def = `        [${col.name}] ${col.type}`;
    
    if (col.identity) {
      const seed = col.identity.seed || 1;
      const increment = col.identity.increment || 1;
      def += ` IDENTITY(${seed},${increment})`;
    }
    
    def += col.nullable ? ' NULL' : ' NOT NULL';
    
    if (col.default !== undefined) {
      def += ` DEFAULT ${col.default}`;
    }
    
    if (col.computed) {
      def = `        [${col.name}] AS ${col.computed}`;
      if (col.persisted) def += ' PERSISTED';
    }
    
    return def;
  }

  buildPrimaryKey(pk, columns) {
    if (pk) return pk;
    
    const idCol = columns.find(c => c.name.toLowerCase() === 'id' || c.identity);
    if (idCol) {
      return { columns: [idCol.name], clustered: true };
    }
    return null;
  }

  buildForeignKeys(foreignKeys) {
    return foreignKeys.map(fk => ({
      name: fk.name,
      column: fk.column,
      refTable: fk.refTable,
      refColumn: fk.refColumn || 'Id',
      refSchema: fk.refSchema,
      onDelete: fk.onDelete,
      onUpdate: fk.onUpdate
    }));
  }

  buildIndexes(indexes, tableName) {
    return indexes.map((idx, i) => ({
      name: idx.name || `IX_${tableName}_${i + 1}`,
      columns: Array.isArray(idx.columns) ? idx.columns : [idx.columns],
      unique: idx.unique || false,
      type: idx.type || 'NONCLUSTERED',
      include: idx.include,
      filter: idx.filter
    }));
  }

  buildParameters(parameters) {
    return parameters.map(p => ({
      name: p.name,
      type: this.toSqlType(p.type, p),
      default: p.default,
      output: p.output || false
    }));
  }

  buildStatements(statements) {
    return statements.map(s => typeof s === 'string' ? s : this.statementToSql(s));
  }

  statementToSql(stmt) {
    switch (stmt.type) {
      case 'addColumn':
        return `ALTER TABLE [${stmt.schema || 'dbo'}].[${stmt.table}] ADD [${stmt.column}] ${this.toSqlType(stmt.dataType, stmt)}`;
      case 'dropColumn':
        return `ALTER TABLE [${stmt.schema || 'dbo'}].[${stmt.table}] DROP COLUMN [${stmt.column}]`;
      case 'addIndex':
        return `CREATE INDEX [${stmt.name}] ON [${stmt.schema || 'dbo'}].[${stmt.table}]([${stmt.columns.join('], [')}])`;
      case 'dropIndex':
        return `DROP INDEX [${stmt.name}] ON [${stmt.schema || 'dbo'}].[${stmt.table}]`;
      default:
        return stmt.sql || '-- Unknown statement';
    }
  }

  toSqlType(type, options = {}) {
    const typeMap = {
      string: options.maxLength ? `NVARCHAR(${options.maxLength})` : 'NVARCHAR(255)',
      text: 'NVARCHAR(MAX)',
      integer: 'INT',
      bigint: 'BIGINT',
      smallint: 'SMALLINT',
      decimal: `DECIMAL(${options.precision || 18}, ${options.scale || 2})`,
      float: 'FLOAT',
      boolean: 'BIT',
      date: 'DATE',
      datetime: 'DATETIME2',
      time: 'TIME',
      guid: 'UNIQUEIDENTIFIER',
      binary: options.maxLength ? `VARBINARY(${options.maxLength})` : 'VARBINARY(MAX)',
      xml: 'XML',
      json: 'NVARCHAR(MAX)'
    };
    return typeMap[type?.toLowerCase()] || type || 'NVARCHAR(255)';
  }

  toSnakeCase(str) {
    return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '').replace(/-/g, '_');
  }

  getTimestamp() {
    return new Date().toISOString().replace(/[-:T]/g, '').slice(0, 14);
  }
}

module.exports = SQLServerGenerator;
