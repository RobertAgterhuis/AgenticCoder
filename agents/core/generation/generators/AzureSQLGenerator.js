/**
 * AzureSQLGenerator - Azure SQL Database Code Generator
 * 
 * Generates Azure SQL schemas, stored procedures, migrations,
 * and Entity Framework configurations.
 */

const BaseGenerator = require('./BaseGenerator');

class AzureSQLGenerator extends BaseGenerator {
  constructor(options = {}) {
    super({
      name: 'AzureSQLGenerator',
      framework: 'azure-sql',
      version: 'latest',
      language: 'sql',
      ...options
    });
    
    this.templatePath = 'database/azure-sql';
    this.supportedTypes = ['schema', 'storedProcedure', 'migration', 'index', 'view'];
  }

  /**
   * Generate an Azure SQL table schema
   */
  async generateSchema(context) {
    const { 
      name, 
      schema = 'dbo',
      columns = [],
      primaryKey,
      foreignKeys = [],
      indexes = [],
      constraints = []
    } = context;
    
    const tableName = this.toPascalCase(name);
    
    const templateData = {
      tableName,
      schema,
      columns: this.buildColumns(columns),
      primaryKey: this.buildPrimaryKey(primaryKey, columns),
      foreignKeys: this.buildForeignKeys(foreignKeys),
      indexes: this.buildIndexes(indexes, tableName),
      constraints: this.buildConstraints(constraints),
      hasColumns: columns.length > 0,
      hasForeignKeys: foreignKeys.length > 0,
      hasIndexes: indexes.length > 0,
      hasConstraints: constraints.length > 0
    };
    
    return this.generateSqlSchema(templateData);
  }

  /**
   * Generate an Azure SQL stored procedure
   */
  async generateStoredProcedure(context) {
    const { 
      name, 
      schema = 'dbo',
      parameters = [],
      returnType = 'table',
      body,
      security = 'EXECUTE AS OWNER'
    } = context;
    
    const procName = 'usp_' + this.toPascalCase(name);
    
    const templateData = {
      procName,
      schema,
      parameters: this.buildParameters(parameters),
      returnType,
      body: body || '-- TODO: implement',
      security,
      hasParameters: parameters.length > 0
    };
    
    return this.generateStoredProcedureSql(templateData);
  }

  /**
   * Generate an Azure SQL migration
   */
  async generateMigration(context) {
    const { 
      name, 
      version,
      up = [],
      down = [],
      description
    } = context;
    
    const migrationName = `${version || this.getTimestamp()}_${this.toSnakeCase(name)}`;
    
    const templateData = {
      migrationName,
      version: version || this.getTimestamp(),
      description: description || name,
      up: this.buildMigrationStatements(up),
      down: this.buildMigrationStatements(down),
      hasUp: up.length > 0,
      hasDown: down.length > 0
    };
    
    return this.generateMigrationSql(templateData);
  }

  /**
   * Generate an Azure SQL view
   */
  async generateView(context) {
    const { 
      name, 
      schema = 'dbo',
      columns = [],
      fromTables = [],
      joins = [],
      where,
      groupBy = [],
      orderBy = []
    } = context;
    
    const viewName = 'vw_' + this.toPascalCase(name);
    
    const templateData = {
      viewName,
      schema,
      columns: this.buildViewColumns(columns),
      fromTables,
      joins: this.buildJoins(joins),
      where,
      groupBy,
      orderBy,
      hasJoins: joins.length > 0,
      hasWhere: where !== undefined,
      hasGroupBy: groupBy.length > 0,
      hasOrderBy: orderBy.length > 0
    };
    
    return this.generateViewSql(templateData);
  }

  // SQL generation methods
  generateSqlSchema(data) {
    const lines = [];
    
    lines.push(`-- Schema: ${data.schema}.${data.tableName}`);
    lines.push(`-- Generated by AgenticCoder`);
    lines.push('');
    
    // Create table
    lines.push(`CREATE TABLE [${data.schema}].[${data.tableName}]`);
    lines.push('(');
    
    // Columns
    const columnDefs = data.columns.map(c => this.formatColumn(c));
    
    // Primary key
    if (data.primaryKey) {
      columnDefs.push(`    CONSTRAINT [PK_${data.tableName}] PRIMARY KEY ${data.primaryKey.clustered ? 'CLUSTERED' : 'NONCLUSTERED'} ([${data.primaryKey.columns.join('], [')}])`);
    }
    
    lines.push(columnDefs.join(',\n'));
    lines.push(');');
    lines.push('GO');
    lines.push('');
    
    // Foreign keys
    for (const fk of data.foreignKeys) {
      lines.push(`ALTER TABLE [${data.schema}].[${data.tableName}]`);
      lines.push(`ADD CONSTRAINT [FK_${data.tableName}_${fk.name}]`);
      lines.push(`FOREIGN KEY ([${fk.column}])`);
      lines.push(`REFERENCES [${fk.refSchema || data.schema}].[${fk.refTable}] ([${fk.refColumn}])`);
      if (fk.onDelete) lines.push(`ON DELETE ${fk.onDelete}`);
      if (fk.onUpdate) lines.push(`ON UPDATE ${fk.onUpdate}`);
      lines.push(';');
      lines.push('GO');
      lines.push('');
    }
    
    // Indexes
    for (const idx of data.indexes) {
      lines.push(`CREATE ${idx.unique ? 'UNIQUE ' : ''}${idx.type || 'NONCLUSTERED'} INDEX [${idx.name}]`);
      lines.push(`ON [${data.schema}].[${data.tableName}] ([${idx.columns.join('], [')}])`);
      if (idx.include?.length) {
        lines.push(`INCLUDE ([${idx.include.join('], [')}])`);
      }
      if (idx.where) {
        lines.push(`WHERE ${idx.where}`);
      }
      lines.push(';');
      lines.push('GO');
      lines.push('');
    }
    
    // Constraints
    for (const con of data.constraints) {
      lines.push(`ALTER TABLE [${data.schema}].[${data.tableName}]`);
      lines.push(`ADD CONSTRAINT [${con.name}] ${con.type} (${con.expression});`);
      lines.push('GO');
      lines.push('');
    }
    
    return lines.join('\n');
  }

  generateStoredProcedureSql(data) {
    const lines = [];
    
    lines.push(`-- Stored Procedure: ${data.schema}.${data.procName}`);
    lines.push(`-- Generated by AgenticCoder`);
    lines.push('');
    
    lines.push(`CREATE OR ALTER PROCEDURE [${data.schema}].[${data.procName}]`);
    
    if (data.hasParameters) {
      const params = data.parameters.map(p => 
        `    @${p.name} ${p.type}${p.default !== undefined ? ` = ${p.default}` : ''}${p.output ? ' OUTPUT' : ''}`
      );
      lines.push(params.join(',\n'));
    }
    
    lines.push('AS');
    lines.push('BEGIN');
    lines.push('    SET NOCOUNT ON;');
    lines.push('    SET XACT_ABORT ON;');
    lines.push('');
    lines.push('    BEGIN TRY');
    lines.push(`        ${data.body}`);
    lines.push('    END TRY');
    lines.push('    BEGIN CATCH');
    lines.push('        THROW;');
    lines.push('    END CATCH');
    lines.push('END');
    lines.push('GO');
    
    return lines.join('\n');
  }

  generateMigrationSql(data) {
    const lines = [];
    
    lines.push(`-- Migration: ${data.migrationName}`);
    lines.push(`-- Description: ${data.description}`);
    lines.push(`-- Generated by AgenticCoder`);
    lines.push('');
    
    lines.push('-- ============================================');
    lines.push('-- UP Migration');
    lines.push('-- ============================================');
    lines.push('');
    
    for (const stmt of data.up) {
      lines.push(stmt);
      lines.push('GO');
      lines.push('');
    }
    
    lines.push('-- ============================================');
    lines.push('-- DOWN Migration (Rollback)');
    lines.push('-- ============================================');
    lines.push('/*');
    
    for (const stmt of data.down) {
      lines.push(stmt);
      lines.push('GO');
      lines.push('');
    }
    
    lines.push('*/');
    
    return lines.join('\n');
  }

  generateViewSql(data) {
    const lines = [];
    
    lines.push(`-- View: ${data.schema}.${data.viewName}`);
    lines.push(`-- Generated by AgenticCoder`);
    lines.push('');
    
    lines.push(`CREATE OR ALTER VIEW [${data.schema}].[${data.viewName}]`);
    lines.push('AS');
    lines.push('SELECT');
    lines.push(`    ${data.columns.join(',\n    ')}`);
    lines.push(`FROM ${data.fromTables[0]}`);
    
    for (const join of data.joins) {
      lines.push(`${join.type} JOIN ${join.table} ON ${join.condition}`);
    }
    
    if (data.hasWhere) {
      lines.push(`WHERE ${data.where}`);
    }
    
    if (data.hasGroupBy) {
      lines.push(`GROUP BY ${data.groupBy.join(', ')}`);
    }
    
    if (data.hasOrderBy) {
      lines.push(`ORDER BY ${data.orderBy.join(', ')}`);
    }
    
    lines.push(';');
    lines.push('GO');
    
    return lines.join('\n');
  }

  // Helper methods
  buildColumns(columns) {
    return columns.map(c => ({
      name: c.name,
      type: this.toSqlType(c.type, c),
      nullable: c.nullable !== false,
      identity: c.identity || false,
      default: c.default,
      computed: c.computed
    }));
  }

  formatColumn(col) {
    let def = `    [${col.name}] ${col.type}`;
    
    if (col.identity) {
      def += ' IDENTITY(1,1)';
    }
    
    def += col.nullable ? ' NULL' : ' NOT NULL';
    
    if (col.default !== undefined) {
      def += ` DEFAULT ${col.default}`;
    }
    
    if (col.computed) {
      def = `    [${col.name}] AS ${col.computed}`;
    }
    
    return def;
  }

  buildPrimaryKey(pk, columns) {
    if (pk) return pk;
    
    const idColumn = columns.find(c => c.name.toLowerCase() === 'id' || c.identity);
    if (idColumn) {
      return { columns: [idColumn.name], clustered: true };
    }
    return null;
  }

  buildForeignKeys(foreignKeys) {
    return foreignKeys.map(fk => ({
      name: fk.name,
      column: fk.column,
      refTable: fk.refTable,
      refColumn: fk.refColumn || 'Id',
      refSchema: fk.refSchema,
      onDelete: fk.onDelete,
      onUpdate: fk.onUpdate
    }));
  }

  buildIndexes(indexes, tableName) {
    return indexes.map((idx, i) => ({
      name: idx.name || `IX_${tableName}_${i + 1}`,
      columns: Array.isArray(idx.columns) ? idx.columns : [idx.columns],
      unique: idx.unique || false,
      type: idx.type || 'NONCLUSTERED',
      include: idx.include,
      where: idx.where
    }));
  }

  buildConstraints(constraints) {
    return constraints.map(c => ({
      name: c.name,
      type: c.type || 'CHECK',
      expression: c.expression
    }));
  }

  buildParameters(parameters) {
    return parameters.map(p => ({
      name: p.name,
      type: this.toSqlType(p.type, p),
      default: p.default,
      output: p.output || false
    }));
  }

  buildMigrationStatements(statements) {
    return statements.map(s => typeof s === 'string' ? s : this.statementToSql(s));
  }

  statementToSql(stmt) {
    switch (stmt.type) {
      case 'addColumn':
        return `ALTER TABLE [${stmt.schema || 'dbo'}].[${stmt.table}] ADD [${stmt.column}] ${this.toSqlType(stmt.dataType, stmt)} ${stmt.nullable ? 'NULL' : 'NOT NULL'}`;
      case 'dropColumn':
        return `ALTER TABLE [${stmt.schema || 'dbo'}].[${stmt.table}] DROP COLUMN [${stmt.column}]`;
      case 'createIndex':
        return `CREATE INDEX [${stmt.name}] ON [${stmt.schema || 'dbo'}].[${stmt.table}] ([${stmt.columns.join('], [')}])`;
      case 'dropIndex':
        return `DROP INDEX [${stmt.name}] ON [${stmt.schema || 'dbo'}].[${stmt.table}]`;
      default:
        return stmt.sql || '-- Unknown statement type';
    }
  }

  buildViewColumns(columns) {
    return columns.map(c => {
      if (typeof c === 'string') return c;
      return c.alias ? `${c.expression} AS [${c.alias}]` : c.expression;
    });
  }

  buildJoins(joins) {
    return joins.map(j => ({
      type: j.type?.toUpperCase() || 'INNER',
      table: j.table,
      condition: j.on || j.condition
    }));
  }

  toSqlType(type, options = {}) {
    const typeMap = {
      string: options.maxLength ? `NVARCHAR(${options.maxLength})` : 'NVARCHAR(255)',
      text: 'NVARCHAR(MAX)',
      integer: 'INT',
      bigint: 'BIGINT',
      smallint: 'SMALLINT',
      tinyint: 'TINYINT',
      decimal: `DECIMAL(${options.precision || 18}, ${options.scale || 2})`,
      float: 'FLOAT',
      boolean: 'BIT',
      date: 'DATE',
      datetime: 'DATETIME2',
      datetimeoffset: 'DATETIMEOFFSET',
      time: 'TIME',
      guid: 'UNIQUEIDENTIFIER',
      uuid: 'UNIQUEIDENTIFIER',
      binary: options.maxLength ? `VARBINARY(${options.maxLength})` : 'VARBINARY(MAX)',
      json: 'NVARCHAR(MAX)',
      xml: 'XML',
      money: 'MONEY'
    };
    return typeMap[type?.toLowerCase()] || type || 'NVARCHAR(255)';
  }

  toSnakeCase(str) {
    return str
      .replace(/([A-Z])/g, '_$1')
      .toLowerCase()
      .replace(/^_/, '')
      .replace(/-/g, '_');
  }

  getTimestamp() {
    const now = new Date();
    return now.toISOString().replace(/[-:T]/g, '').slice(0, 14);
  }
}

module.exports = AzureSQLGenerator;
