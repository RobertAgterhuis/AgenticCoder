/**
 * NetworkingGenerator - Azure Networking Generator
 * 
 * Generates VNet configurations, NSG rules, Private Endpoints,
 * and other networking artifacts.
 */

const BaseGenerator = require('./BaseGenerator');

class NetworkingGenerator extends BaseGenerator {
  constructor(options = {}) {
    super({
      name: 'NetworkingGenerator',
      framework: 'azure-networking',
      version: 'latest',
      language: 'bicep',
      ...options
    });
    
    this.templatePath = 'azure/networking';
    this.supportedTypes = ['vnet', 'nsg', 'privateEndpoint', 'dns'];
  }

  /**
   * Generate Virtual Network configuration
   */
  async generateVnet(context) {
    const { 
      name,
      addressSpace = ['10.0.0.0/16'],
      subnets = [],
      location = 'eastus',
      tags = {}
    } = context;
    
    const templateData = {
      name: this.toKebabCase(name),
      addressSpace,
      subnets: this.buildSubnets(subnets),
      location,
      tags
    };
    
    return this.generateVnetBicep(templateData);
  }

  /**
   * Generate Network Security Group
   */
  async generateNsg(context) {
    const { 
      name,
      rules = [],
      location = 'eastus',
      tags = {}
    } = context;
    
    const templateData = {
      name: this.toKebabCase(name),
      rules: this.buildNsgRules(rules),
      location,
      tags
    };
    
    return this.generateNsgBicep(templateData);
  }

  /**
   * Generate Private Endpoint configuration
   */
  async generatePrivateEndpoint(context) {
    const { 
      name,
      targetResource,
      targetSubResource,
      subnetId,
      privateDnsZone,
      location = 'eastus',
      tags = {}
    } = context;
    
    const templateData = {
      name: this.toKebabCase(name),
      targetResource,
      targetSubResource,
      subnetId,
      privateDnsZone,
      location,
      tags
    };
    
    return this.generatePrivateEndpointBicep(templateData);
  }

  /**
   * Generate Private DNS Zone configuration
   */
  async generateDns(context) {
    const { 
      name,
      vnetLinks = [],
      records = [],
      tags = {}
    } = context;
    
    const templateData = {
      name,
      vnetLinks: this.buildVnetLinks(vnetLinks),
      records: this.buildDnsRecords(records),
      tags
    };
    
    return this.generateDnsBicep(templateData);
  }

  // Bicep generators
  generateVnetBicep(data) {
    const lines = [];
    
    lines.push('// Azure Virtual Network');
    lines.push('// Generated by AgenticCoder');
    lines.push('');
    lines.push('@description(\'Name of the virtual network\')');
    lines.push(`param vnetName string = '${data.name}'`);
    lines.push('');
    lines.push('@description(\'Location for the virtual network\')');
    lines.push(`param location string = '${data.location}'`);
    lines.push('');
    lines.push('@description(\'Address space for the virtual network\')');
    lines.push(`param addressPrefixes array = ${JSON.stringify(data.addressSpace)}`);
    lines.push('');
    lines.push('@description(\'Tags for the resources\')');
    lines.push(`param tags object = ${JSON.stringify(data.tags)}`);
    lines.push('');
    
    // Subnet parameters
    for (let i = 0; i < data.subnets.length; i++) {
      const subnet = data.subnets[i];
      lines.push(`@description('Address prefix for ${subnet.name} subnet')`);
      lines.push(`param ${this.toCamelCase(subnet.name)}AddressPrefix string = '${subnet.addressPrefix}'`);
      lines.push('');
    }
    
    lines.push('resource vnet \'Microsoft.Network/virtualNetworks@2023-05-01\' = {');
    lines.push('  name: vnetName');
    lines.push('  location: location');
    lines.push('  tags: tags');
    lines.push('  properties: {');
    lines.push('    addressSpace: {');
    lines.push('      addressPrefixes: addressPrefixes');
    lines.push('    }');
    lines.push('    subnets: [');
    
    for (let i = 0; i < data.subnets.length; i++) {
      const subnet = data.subnets[i];
      lines.push('      {');
      lines.push(`        name: '${subnet.name}'`);
      lines.push('        properties: {');
      lines.push(`          addressPrefix: ${this.toCamelCase(subnet.name)}AddressPrefix`);
      
      if (subnet.nsgId) {
        lines.push('          networkSecurityGroup: {');
        lines.push(`            id: '${subnet.nsgId}'`);
        lines.push('          }');
      }
      
      if (subnet.serviceEndpoints?.length) {
        lines.push('          serviceEndpoints: [');
        for (const endpoint of subnet.serviceEndpoints) {
          lines.push('            {');
          lines.push(`              service: '${endpoint}'`);
          lines.push('            }');
        }
        lines.push('          ]');
      }
      
      if (subnet.delegations?.length) {
        lines.push('          delegations: [');
        for (const delegation of subnet.delegations) {
          lines.push('            {');
          lines.push(`              name: '${delegation.name}'`);
          lines.push('              properties: {');
          lines.push(`                serviceName: '${delegation.serviceName}'`);
          lines.push('              }');
          lines.push('            }');
        }
        lines.push('          ]');
      }
      
      if (subnet.privateEndpointNetworkPolicies) {
        lines.push(`          privateEndpointNetworkPolicies: '${subnet.privateEndpointNetworkPolicies}'`);
      }
      
      lines.push('        }');
      lines.push('      }');
    }
    
    lines.push('    ]');
    lines.push('  }');
    lines.push('}');
    lines.push('');
    
    // Outputs
    lines.push('output vnetId string = vnet.id');
    lines.push('output vnetName string = vnet.name');
    
    for (const subnet of data.subnets) {
      const subnetName = this.toCamelCase(subnet.name);
      lines.push(`output ${subnetName}SubnetId string = vnet.properties.subnets[${data.subnets.indexOf(subnet)}].id`);
    }
    
    return lines.join('\n');
  }

  generateNsgBicep(data) {
    const lines = [];
    
    lines.push('// Azure Network Security Group');
    lines.push('// Generated by AgenticCoder');
    lines.push('');
    lines.push('@description(\'Name of the network security group\')');
    lines.push(`param nsgName string = '${data.name}'`);
    lines.push('');
    lines.push('@description(\'Location for the NSG\')');
    lines.push(`param location string = '${data.location}'`);
    lines.push('');
    lines.push('@description(\'Tags for the resources\')');
    lines.push(`param tags object = ${JSON.stringify(data.tags)}`);
    lines.push('');
    
    lines.push('resource nsg \'Microsoft.Network/networkSecurityGroups@2023-05-01\' = {');
    lines.push('  name: nsgName');
    lines.push('  location: location');
    lines.push('  tags: tags');
    lines.push('  properties: {');
    lines.push('    securityRules: [');
    
    for (const rule of data.rules) {
      lines.push('      {');
      lines.push(`        name: '${rule.name}'`);
      lines.push('        properties: {');
      lines.push(`          priority: ${rule.priority}`);
      lines.push(`          direction: '${rule.direction}'`);
      lines.push(`          access: '${rule.access}'`);
      lines.push(`          protocol: '${rule.protocol}'`);
      lines.push(`          sourcePortRange: '${rule.sourcePortRange || '*'}'`);
      lines.push(`          destinationPortRange: '${rule.destinationPortRange}'`);
      lines.push(`          sourceAddressPrefix: '${rule.sourceAddressPrefix}'`);
      lines.push(`          destinationAddressPrefix: '${rule.destinationAddressPrefix}'`);
      if (rule.description) {
        lines.push(`          description: '${rule.description}'`);
      }
      lines.push('        }');
      lines.push('      }');
    }
    
    lines.push('    ]');
    lines.push('  }');
    lines.push('}');
    lines.push('');
    lines.push('output nsgId string = nsg.id');
    lines.push('output nsgName string = nsg.name');
    
    return lines.join('\n');
  }

  generatePrivateEndpointBicep(data) {
    const lines = [];
    
    lines.push('// Azure Private Endpoint');
    lines.push('// Generated by AgenticCoder');
    lines.push('');
    lines.push('@description(\'Name of the private endpoint\')');
    lines.push(`param privateEndpointName string = '${data.name}'`);
    lines.push('');
    lines.push('@description(\'Location for the private endpoint\')');
    lines.push(`param location string = '${data.location}'`);
    lines.push('');
    lines.push('@description(\'Resource ID of the target resource\')');
    lines.push(`param targetResourceId string`);
    lines.push('');
    lines.push('@description(\'Sub-resource type to connect to\')');
    lines.push(`param groupId string = '${data.targetSubResource}'`);
    lines.push('');
    lines.push('@description(\'Subnet ID for the private endpoint\')');
    lines.push('param subnetId string');
    lines.push('');
    
    if (data.privateDnsZone) {
      lines.push('@description(\'Private DNS Zone ID\')');
      lines.push('param privateDnsZoneId string');
      lines.push('');
    }
    
    lines.push('@description(\'Tags for the resources\')');
    lines.push(`param tags object = ${JSON.stringify(data.tags)}`);
    lines.push('');
    
    lines.push('resource privateEndpoint \'Microsoft.Network/privateEndpoints@2023-05-01\' = {');
    lines.push('  name: privateEndpointName');
    lines.push('  location: location');
    lines.push('  tags: tags');
    lines.push('  properties: {');
    lines.push('    subnet: {');
    lines.push('      id: subnetId');
    lines.push('    }');
    lines.push('    privateLinkServiceConnections: [');
    lines.push('      {');
    lines.push(`        name: '\${privateEndpointName}-connection'`);
    lines.push('        properties: {');
    lines.push('          privateLinkServiceId: targetResourceId');
    lines.push('          groupIds: [');
    lines.push('            groupId');
    lines.push('          ]');
    lines.push('        }');
    lines.push('      }');
    lines.push('    ]');
    lines.push('  }');
    lines.push('}');
    lines.push('');
    
    if (data.privateDnsZone) {
      lines.push('resource privateDnsZoneGroup \'Microsoft.Network/privateEndpoints/privateDnsZoneGroups@2023-05-01\' = {');
      lines.push('  parent: privateEndpoint');
      lines.push("  name: 'default'");
      lines.push('  properties: {');
      lines.push('    privateDnsZoneConfigs: [');
      lines.push('      {');
      lines.push("        name: 'config1'");
      lines.push('        properties: {');
      lines.push('          privateDnsZoneId: privateDnsZoneId');
      lines.push('        }');
      lines.push('      }');
      lines.push('    ]');
      lines.push('  }');
      lines.push('}');
      lines.push('');
    }
    
    lines.push('output privateEndpointId string = privateEndpoint.id');
    lines.push('output privateEndpointName string = privateEndpoint.name');
    
    return lines.join('\n');
  }

  generateDnsBicep(data) {
    const lines = [];
    
    lines.push('// Azure Private DNS Zone');
    lines.push('// Generated by AgenticCoder');
    lines.push('');
    lines.push('@description(\'Name of the private DNS zone\')');
    lines.push(`param dnsZoneName string = '${data.name}'`);
    lines.push('');
    lines.push('@description(\'Tags for the resources\')');
    lines.push(`param tags object = ${JSON.stringify(data.tags)}`);
    lines.push('');
    
    lines.push('resource privateDnsZone \'Microsoft.Network/privateDnsZones@2020-06-01\' = {');
    lines.push('  name: dnsZoneName');
    lines.push("  location: 'global'");
    lines.push('  tags: tags');
    lines.push('}');
    lines.push('');
    
    // VNet Links
    for (let i = 0; i < data.vnetLinks.length; i++) {
      const link = data.vnetLinks[i];
      lines.push(`resource vnetLink${i} 'Microsoft.Network/privateDnsZones/virtualNetworkLinks@2020-06-01' = {`);
      lines.push('  parent: privateDnsZone');
      lines.push(`  name: '${link.name}'`);
      lines.push("  location: 'global'");
      lines.push('  properties: {');
      lines.push('    virtualNetwork: {');
      lines.push(`      id: '${link.vnetId}'`);
      lines.push('    }');
      lines.push(`    registrationEnabled: ${link.registrationEnabled || false}`);
      lines.push('  }');
      lines.push('}');
      lines.push('');
    }
    
    // DNS Records
    for (const record of data.records) {
      const recordType = record.type.toUpperCase();
      lines.push(`resource ${this.toCamelCase(record.name)}Record 'Microsoft.Network/privateDnsZones/${recordType}@2020-06-01' = {`);
      lines.push('  parent: privateDnsZone');
      lines.push(`  name: '${record.name}'`);
      lines.push('  properties: {');
      lines.push(`    ttl: ${record.ttl || 3600}`);
      
      switch (recordType) {
        case 'A':
          lines.push('    aRecords: [');
          for (const ip of record.values || []) {
            lines.push(`      { ipv4Address: '${ip}' }`);
          }
          lines.push('    ]');
          break;
        case 'CNAME':
          lines.push(`    cnameRecord: { cname: '${record.values?.[0]}' }`);
          break;
        case 'TXT':
          lines.push('    txtRecords: [');
          for (const value of record.values || []) {
            lines.push(`      { value: ['${value}'] }`);
          }
          lines.push('    ]');
          break;
      }
      
      lines.push('  }');
      lines.push('}');
      lines.push('');
    }
    
    lines.push('output dnsZoneId string = privateDnsZone.id');
    lines.push('output dnsZoneName string = privateDnsZone.name');
    
    return lines.join('\n');
  }

  // Helper methods
  buildSubnets(subnets) {
    return subnets.map(s => ({
      name: s.name,
      addressPrefix: s.addressPrefix,
      nsgId: s.nsgId,
      serviceEndpoints: s.serviceEndpoints || [],
      delegations: s.delegations || [],
      privateEndpointNetworkPolicies: s.privateEndpointNetworkPolicies || 'Disabled'
    }));
  }

  buildNsgRules(rules) {
    return rules.map((r, i) => ({
      name: r.name,
      priority: r.priority || (100 + i * 10),
      direction: r.direction || 'Inbound',
      access: r.access || 'Allow',
      protocol: r.protocol || 'Tcp',
      sourcePortRange: r.sourcePortRange || '*',
      destinationPortRange: r.destinationPortRange,
      sourceAddressPrefix: r.sourceAddressPrefix || '*',
      destinationAddressPrefix: r.destinationAddressPrefix || '*',
      description: r.description
    }));
  }

  buildVnetLinks(links) {
    return links.map(l => ({
      name: l.name,
      vnetId: l.vnetId,
      registrationEnabled: l.registrationEnabled || false
    }));
  }

  buildDnsRecords(records) {
    return records.map(r => ({
      name: r.name,
      type: r.type || 'A',
      ttl: r.ttl || 3600,
      values: Array.isArray(r.values) ? r.values : [r.values]
    }));
  }
}

module.exports = NetworkingGenerator;
